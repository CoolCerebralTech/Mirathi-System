// src/domain/entities/compliance-check.entity.ts
import { Entity } from '../base/entity';
import { UniqueEntityID } from '../base/unique-entity-id';
import {
  ComplianceAmendmentRequestedEvent,
  ComplianceReportAcceptedEvent,
  ComplianceReportSubmittedEvent,
  ComplianceSectionCompletedEvent,
  SectionAutoGeneratedEvent,
} from '../events/compliance-events';
import { ComplianceScheduleVO } from '../value-objects/compliance-schedule.vo';

export interface ComplianceCheckProps {
  // Core Identity
  guardianshipId: string;
  year: number;
  reportingPeriod: CompliancePeriod;

  // Schedule & Timeline
  schedule: ComplianceScheduleVO;
  dueDate: Date;
  submissionDeadline: Date;

  // Status Tracking
  status: ComplianceStatus;
  submissionDate?: Date;
  acceptedDate?: Date;
  reviewedDate?: Date;

  // ðŸŽ¯ INNOVATIVE: Multi-channel submission tracking
  submissionMethods: SubmissionMethod[];
  submissionReferences: Array<{
    method: string;
    reference: string;
    timestamp: Date;
  }>;

  // ðŸŽ¯ INNOVATIVE: Smart content generation
  reportType: ReportType;
  autoGenerated: boolean;
  generatedSections: Array<{
    sectionId: string;
    sectionName: string;
    status: 'AUTO_GENERATED' | 'MANUAL' | 'PARTIAL';
    confidenceScore: number; // 0-100 for AI-generated content
  }>;

  // Report Content
  reportTitle: string;
  executiveSummary?: string;
  sections: ComplianceSection[];
  attachments: ComplianceAttachment[];

  // ðŸŽ¯ INNOVATIVE: Validation & Quality Control
  validationStatus: ValidationStatus;
  validationErrors: ValidationError[];
  qualityScore: number; // 0-100

  // Financial Reporting (for property guardians)
  financialStatement?: FinancialStatement;
  bankReconciliation?: BankReconciliation[];

  // Ward Welfare Reporting
  wardStatus: WardStatusReport;
  educationalProgress?: EducationalProgress;
  healthUpdates?: HealthUpdates;

  // ðŸŽ¯ INNOVATIVE: Court Integration
  courtSubmission?: CourtSubmission;
  courtFeedback?: CourtFeedback[];

  // ðŸŽ¯ INNOVATIVE: Guardian Performance
  guardianPerformance?: GuardianPerformance;
  recommendations?: Recommendation[];

  // Metadata
  notes?: string;
  internalComments?: string;
  externalNotes?: string; // For guardians/courts

  // Audit Trail
  createdBy?: string;
  submittedBy?: string;
  reviewedBy?: string;
  approvedBy?: string;

  // ðŸŽ¯ INNOVATIVE: Smart reminders & follow-ups
  reminderHistory: ReminderEvent[];
  followUpActions: FollowUpAction[];
}

export enum CompliancePeriod {
  QUARTER_1 = 'Q1', // Jan-Mar
  QUARTER_2 = 'Q2', // Apr-Jun
  QUARTER_3 = 'Q3', // Jul-Sep
  QUARTER_4 = 'Q4', // Oct-Dec
  ANNUAL = 'ANNUAL',
  BIANNUAL = 'BIANNUAL',
  SPECIAL = 'SPECIAL', // Ad-hoc court ordered
}

export enum ComplianceStatus {
  DRAFT = 'DRAFT',
  PENDING_SUBMISSION = 'PENDING_SUBMISSION',
  SUBMITTED = 'SUBMITTED',
  UNDER_REVIEW = 'UNDER_REVIEW',
  ACCEPTED = 'ACCEPTED',
  REJECTED = 'REJECTED',
  AMENDMENT_REQUESTED = 'AMENDMENT_REQUESTED',
  OVERDUE = 'OVERDUE',
  EXTENSION_GRANTED = 'EXTENSION_GRANTED',
  WAIVED = 'WAIVED', // Court waived requirement
}

export enum ReportType {
  ANNUAL_WELFARE = 'ANNUAL_WELFARE',
  QUARTERLY_FINANCIAL = 'QUARTERLY_FINANCIAL',
  MEDICAL_UPDATE = 'MEDICAL_UPDATE',
  EDUCATIONAL_PROGRESS = 'EDUCATIONAL_PROGRESS',
  PROPERTY_MANAGEMENT = 'PROPERTY_MANAGEMENT',
  COURT_MANDATED = 'COURT_MANDATED',
  EMERGENCY_REPORT = 'EMERGENCY_REPORT',
  CLOSING_REPORT = 'CLOSING_REPORT', // When guardianship ends
}

export interface SubmissionMethod {
  method: 'E_FILING' | 'EMAIL' | 'PHYSICAL' | 'COURT_PORTAL' | 'LAWYER';
  details: string;
  timestamp: Date;
  confirmationNumber?: string;
}

export interface ComplianceSection {
  id: string;
  title: string;
  type: 'TEXT' | 'FINANCIAL' | 'EDUCATION' | 'HEALTH' | 'LEGAL';
  content: string | Record<string, any>;
  isRequired: boolean;
  isComplete: boolean;
  validationRules?: ValidationRule[];
}

export interface ComplianceAttachment {
  id: string;
  name: string;
  type: string;
  size: number;
  url: string;
  description?: string;
  uploadedAt: Date;
  verified: boolean;
  verificationMethod?: string;
}

export enum ValidationStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  PASSED = 'PASSED',
  FAILED = 'FAILED',
  EXCEPTION = 'EXCEPTION', // Manual review needed
}

export interface ValidationError {
  code: string;
  section: string;
  message: string;
  severity: 'ERROR' | 'WARNING' | 'INFO';
  suggestedFix?: string;
  autoCorrectable: boolean;
}

export interface FinancialStatement {
  openingBalance: number;
  closingBalance: number;
  income: Array<{ description: string; amount: number; date: Date }>;
  expenses: Array<{ description: string; amount: number; date: Date; category: string }>;
  investments?: Array<{ description: string; value: number; performance: number }>;
  debts?: Array<{ description: string; amount: number; interestRate: number }>;
  netWorthChange: number;
  auditorNotes?: string;
}

export interface BankReconciliation {
  bankName: string;
  accountNumber: string;
  statementBalance: number;
  systemBalance: number;
  difference: number;
  reconciled: boolean;
  reconciliationDate?: Date;
}

export interface WardStatusReport {
  generalHealth: 'EXCELLENT' | 'GOOD' | 'FAIR' | 'POOR';
  emotionalWellbeing: 'HAPPY' | 'CONTENT' | 'NEUTRAL' | 'DISTRESSED';
  livingConditions: 'EXCELLENT' | 'ADEQUATE' | 'INADEQUATE';
  notableEvents: Array<{ date: Date; description: string; impact: string }>;
  concerns?: string;
  photos?: Array<{ url: string; caption: string; date: Date }>;
}

export interface EducationalProgress {
  schoolName: string;
  grade: string;
  performance: 'EXCELLENT' | 'GOOD' | 'AVERAGE' | 'POOR';
  attendance: number; // Percentage
  teacherComments?: string;
  reportCardUrl?: string;
  awards?: Array<{ name: string; date: Date }>;
  areasForImprovement?: string[];
}

export interface HealthUpdates {
  generalHealth: string;
  medicalAppointments: Array<{ date: Date; doctor: string; purpose: string; followUp?: string }>;
  medications: Array<{ name: string; dosage: string; frequency: string }>;
  vaccinations: Array<{ name: string; date: Date; nextDue?: Date }>;
  allergies?: string[];
  specialNeeds?: string;
  insuranceCoverage?: string;
}

export interface CourtSubmission {
  courtCaseNumber: string;
  filingDate: Date;
  filingMethod: string;
  courtOfficial?: string;
  receiptNumber?: string;
  hearingDate?: Date;
  notes?: string;
}

export interface CourtFeedback {
  date: Date;
  courtOfficial: string;
  feedbackType: 'APPROVAL' | 'REVISION' | 'REJECTION' | 'QUERY';
  comments: string;
  actionRequired?: string;
  deadline?: Date;
}

export interface GuardianPerformance {
  tasksCompleted: number;
  tasksOverdue: number;
  communicationScore: number; // 0-100
  careQualityScore: number; // 0-100
  financialManagementScore: number; // 0-100
  overallScore: number; // 0-100
  strengths: string[];
  areasForImprovement: string[];
  recommendationForContinuation: boolean;
}

export interface Recommendation {
  type: 'GENERAL' | 'FINANCIAL' | 'EDUCATIONAL' | 'HEALTH' | 'LEGAL';
  priority: 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;
  actionSteps: string[];
  deadline?: Date;
  responsibleParty?: string;
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'DEFERRED';
}

export interface ReminderEvent {
  type: 'EMAIL' | 'SMS' | 'PUSH' | 'SYSTEM';
  sentAt: Date;
  recipient: string;
  content: string;
  acknowledged: boolean;
  acknowledgedAt?: Date;
}

export interface FollowUpAction {
  type: 'DOCUMENT_REQUEST' | 'CLARIFICATION' | 'MEETING' | 'COURT_APPEARANCE';
  description: string;
  assignedTo: string;
  dueDate: Date;
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';
  outcome?: string;
}

export interface ValidationRule {
  field: string;
  rule: 'REQUIRED' | 'NUMERIC' | 'DATE' | 'MIN_VALUE' | 'MAX_VALUE' | 'REGEX';
  value?: any;
  errorMessage: string;
}

export class ComplianceCheckEntity extends Entity<ComplianceCheckProps> {
  constructor(id: UniqueEntityID, props: ComplianceCheckProps) {
    super(id, props);
    this.validate();
  }

  private validate(): void {
    this.ensureNotDeleted();

    // Validate dates
    if (this.props.dueDate < new Date()) {
      throw new Error('Due date cannot be in the past for new compliance check');
    }

    if (this.props.submissionDeadline <= this.props.dueDate) {
      throw new Error('Submission deadline must be after due date');
    }

    // Validate year matches reporting period
    if (this.props.year > new Date().getFullYear() + 1) {
      throw new Error('Compliance check year cannot be more than 1 year in the future');
    }

    // Validate quality score
    if (this.props.qualityScore < 0 || this.props.qualityScore > 100) {
      throw new Error('Quality score must be between 0 and 100');
    }

    // Validate required sections
    const requiredSections = this.props.sections.filter((s) => s.isRequired);
    const incompleteRequired = requiredSections.filter((s) => !s.isComplete);
    if (incompleteRequired.length > 0 && this.props.status !== ComplianceStatus.DRAFT) {
      throw new Error('All required sections must be complete before submission');
    }
  }

  // ðŸŽ¯ INNOVATIVE: Smart status transitions with validation
  public submit(submissionMethod: SubmissionMethod): void {
    if (
      this.props.status !== ComplianceStatus.DRAFT &&
      this.props.status !== ComplianceStatus.PENDING_SUBMISSION
    ) {
      throw new Error('Only draft or pending reports can be submitted');
    }

    // Validate report completeness
    this.validateReportCompleteness();

    // Run automated validation
    const validationResult = this.runAutomatedValidation();
    if (!validationResult.isValid && validationResult.criticalErrors > 0) {
      throw new Error('Report has critical validation errors. Please fix before submission.');
    }

    // Update status using type assertion
    const props = this.props as any;
    props.status = ComplianceStatus.SUBMITTED;
    props.submissionDate = new Date();
    props.submissionMethods.push(submissionMethod);
    props.submissionReferences.push({
      method: submissionMethod.method,
      reference: submissionMethod.confirmationNumber || '',
      timestamp: submissionMethod.timestamp,
    });

    // Add reminder event for acknowledgment
    this.addReminderEvent({
      type: 'SYSTEM',
      sentAt: new Date(),
      recipient: 'GUARDIAN',
      content: `Report submitted successfully. Confirmation: ${submissionMethod.confirmationNumber}`,
      acknowledged: false,
    });

    this.incrementVersion();
    this.addDomainEvent(
      new ComplianceReportSubmittedEvent({
        complianceCheckId: this.id.toString(),
        guardianshipId: this.props.guardianshipId,
        year: this.props.year,
        submissionMethod: submissionMethod.method,
        validationScore: validationResult.score,
      }),
    );
  }

  // ðŸŽ¯ INNOVATIVE: Automated report validation engine
  private runAutomatedValidation(): {
    isValid: boolean;
    errors: ValidationError[];
    warnings: ValidationError[];
    criticalErrors: number;
    score: number;
  } {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // Check required sections
    const requiredSections = this.props.sections.filter((s) => s.isRequired);
    const incompleteRequired = requiredSections.filter((s) => !s.isComplete);

    incompleteRequired.forEach((section) => {
      errors.push({
        code: 'REQUIRED_SECTION_INCOMPLETE',
        section: section.title,
        message: `Required section "${section.title}" is incomplete`,
        severity: 'ERROR',
        autoCorrectable: false,
      });
    });

    // Validate financial data if present
    if (this.props.financialStatement) {
      this.validateFinancialStatement(errors, warnings);
    }

    // Validate dates
    if (this.props.submissionDate && this.props.submissionDate > this.props.submissionDeadline) {
      warnings.push({
        code: 'LATE_SUBMISSION',
        section: 'Submission',
        message: 'Report was submitted after the deadline',
        severity: 'WARNING',
        autoCorrectable: false,
      });
    }

    // Calculate quality score based on completeness
    const totalSections = this.props.sections.length;
    const completeSections = this.props.sections.filter((s) => s.isComplete).length;
    const completenessScore = totalSections > 0 ? (completeSections / totalSections) * 100 : 0;

    // Adjust score based on errors/warnings
    const errorPenalty = errors.length * 10;
    const warningPenalty = warnings.length * 5;
    let finalScore = completenessScore - errorPenalty - warningPenalty;
    finalScore = Math.max(0, Math.min(100, finalScore));

    // Update properties using type assertion
    const props = this.props as any;
    props.qualityScore = finalScore;
    props.validationStatus = errors.length > 0 ? ValidationStatus.FAILED : ValidationStatus.PASSED;
    props.validationErrors = [...errors, ...warnings];

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      criticalErrors: errors.length,
      score: finalScore,
    };
  }

  private validateFinancialStatement(errors: ValidationError[], warnings: ValidationError[]): void {
    if (!this.props.financialStatement) return;

    const fs = this.props.financialStatement;

    // Check for negative balances
    if (fs.closingBalance < 0) {
      warnings.push({
        code: 'NEGATIVE_BALANCE',
        section: 'Financial Statement',
        message: 'Closing balance is negative',
        severity: 'WARNING',
        autoCorrectable: false,
      });
    }

    // Check for unusually large expenses
    const largeExpenses = fs.expenses.filter((e) => e.amount > 100000); // KES 100,000 threshold
    if (largeExpenses.length > 0) {
      warnings.push({
        code: 'LARGE_EXPENSES',
        section: 'Financial Statement',
        message: `${largeExpenses.length} unusually large expenses detected`,
        severity: 'WARNING',
        autoCorrectable: false,
      });
    }

    // Validate bank reconciliation
    if (this.props.bankReconciliation) {
      this.props.bankReconciliation.forEach((rec, index) => {
        if (!rec.reconciled && Math.abs(rec.difference) > 1000) {
          // KES 1,000 tolerance
          errors.push({
            code: 'UNRECONCILED_ACCOUNT',
            section: `Bank Reconciliation ${index + 1}`,
            message: `Account ${rec.accountNumber} has unreconciled difference of KES ${rec.difference}`,
            severity: 'ERROR',
            autoCorrectable: false,
          });
        }
      });
    }
  }

  private validateReportCompleteness(): void {
    const requiredSections = this.props.sections.filter((s) => s.isRequired);
    const incompleteRequired = requiredSections.filter((s) => !s.isComplete);

    if (incompleteRequired.length > 0) {
      throw new Error(
        `Required sections incomplete: ${incompleteRequired.map((s) => s.title).join(', ')}`,
      );
    }
  }

  // ðŸŽ¯ INNOVATIVE: Court acceptance with feedback
  public accept(acceptedBy: string, courtFeedback?: CourtFeedback): void {
    if (
      this.props.status !== ComplianceStatus.SUBMITTED &&
      this.props.status !== ComplianceStatus.UNDER_REVIEW
    ) {
      throw new Error('Only submitted or under-review reports can be accepted');
    }

    const props = this.props as any;
    props.status = ComplianceStatus.ACCEPTED;
    props.acceptedDate = new Date();
    props.reviewedDate = new Date();
    props.reviewedBy = acceptedBy;

    if (courtFeedback) {
      props.courtFeedback = props.courtFeedback || [];
      props.courtFeedback.push(courtFeedback);
    }

    this.addReminderEvent({
      type: 'SYSTEM',
      sentAt: new Date(),
      recipient: 'GUARDIAN',
      content: 'Report accepted by court. No further action required.',
      acknowledged: false,
    });

    this.incrementVersion();
    this.addDomainEvent(
      new ComplianceReportAcceptedEvent({
        complianceCheckId: this.id.toString(),
        acceptedBy,
        qualityScore: this.props.qualityScore,
      }),
    );
  }

  // ðŸŽ¯ INNOVATIVE: Amendment request with specific instructions
  public requestAmendment(feedback: CourtFeedback, newDeadline?: Date): void {
    const props = this.props as any;
    props.status = ComplianceStatus.AMENDMENT_REQUESTED;
    props.reviewedDate = new Date();
    props.courtFeedback = props.courtFeedback || [];
    props.courtFeedback.push(feedback);

    if (newDeadline) {
      props.submissionDeadline = newDeadline;
    }

    // Create follow-up action for guardian
    this.addFollowUpAction({
      type: 'DOCUMENT_REQUEST',
      description: feedback.actionRequired || 'Address court feedback in report',
      assignedTo: 'GUARDIAN',
      dueDate: newDeadline || this.props.submissionDeadline,
      status: 'PENDING',
    });

    this.addReminderEvent({
      type: 'EMAIL',
      sentAt: new Date(),
      recipient: 'GUARDIAN',
      content: `Amendment requested: ${feedback.comments}`,
      acknowledged: false,
    });

    this.incrementVersion();
    this.addDomainEvent(
      new ComplianceAmendmentRequestedEvent({
        complianceCheckId: this.id.toString(),
        feedbackType: feedback.feedbackType,
        deadline: newDeadline,
      }),
    );
  }

  // ðŸŽ¯ INNOVATIVE: Smart section completion with auto-validation
  public completeSection(sectionId: string, content: any): void {
    const section = this.props.sections.find((s) => s.id === sectionId);
    if (!section) {
      throw new Error(`Section ${sectionId} not found`);
    }

    section.content = content;
    section.isComplete = true;

    // Auto-validate section if rules exist
    if (section.validationRules) {
      this.validateSection(section);
    }

    // Update auto-generated sections confidence
    const generatedSection = this.props.generatedSections.find((s) => s.sectionId === sectionId);
    if (generatedSection && generatedSection.status === 'AUTO_GENERATED') {
      generatedSection.confidenceScore = Math.min(100, generatedSection.confidenceScore + 20); // Increase confidence on manual completion
    }

    this.incrementVersion();
    this.addDomainEvent(
      new ComplianceSectionCompletedEvent({
        complianceCheckId: this.id.toString(),
        sectionId,
        sectionTitle: section.title,
      }),
    );
  }

  private validateSection(section: ComplianceSection): void {
    if (!section.validationRules) return;

    section.validationRules.forEach((rule) => {
      let isValid = true;
      let value = section.content;

      if (typeof value === 'object' && rule.field) {
        value = (section.content as Record<string, any>)[rule.field];
      }

      switch (rule.rule) {
        case 'REQUIRED':
          isValid = value !== null && value !== undefined && value !== '';
          break;
        case 'NUMERIC':
          isValid = !isNaN(Number(value));
          break;
        case 'DATE':
          isValid = !isNaN(Date.parse(value as string));
          break;
        case 'MIN_VALUE':
          isValid = Number(value) >= rule.value;
          break;
        case 'MAX_VALUE':
          isValid = Number(value) <= rule.value;
          break;
        case 'REGEX': {
          // Wrap in block to avoid ESLint no-case-declarations error
          const regex = new RegExp(rule.value);
          isValid = regex.test(String(value as string));
          break;
        }
      }

      if (!isValid) {
        const props = this.props as any;
        props.validationErrors.push({
          code: `SECTION_${rule.rule}`,
          section: section.title,
          message: rule.errorMessage,
          severity: 'ERROR',
          autoCorrectable: rule.rule === 'NUMERIC' || rule.rule === 'DATE',
          suggestedFix: rule.rule === 'REQUIRED' ? 'Please fill this field' : undefined,
        });
      }
    });
  }

  // ðŸŽ¯ INNOVATIVE: Auto-generate report sections using AI/ML
  public autoGenerateSection(sectionId: string, dataSource: string): void {
    const section = this.props.sections.find((s) => s.id === sectionId);
    if (!section) {
      throw new Error(`Section ${sectionId} not found`);
    }

    // Simulate AI generation - in real system, this would call ML service
    const generatedContent = this.simulateAIGeneration(sectionId, dataSource);

    section.content = generatedContent.content;
    section.isComplete = generatedContent.isComplete;

    // Track generation
    let generatedSection = this.props.generatedSections.find((s) => s.sectionId === sectionId);
    if (!generatedSection) {
      generatedSection = {
        sectionId,
        sectionName: section.title,
        status: 'AUTO_GENERATED',
        confidenceScore: generatedContent.confidence,
      };
      const props = this.props as any;
      props.generatedSections.push(generatedSection);
    } else {
      generatedSection.status = 'AUTO_GENERATED';
      generatedSection.confidenceScore = generatedContent.confidence;
    }

    this.incrementVersion();
    this.addDomainEvent(
      new SectionAutoGeneratedEvent({
        complianceCheckId: this.id.toString(),
        sectionId,
        confidenceScore: generatedContent.confidence,
        dataSource,
      }),
    );
  }

  private simulateAIGeneration(
    sectionId: string,
    _dataSource: string,
  ): {
    content: any;
    isComplete: boolean;
    confidence: number;
  } {
    // This is a simulation - real implementation would use ML models
    const templates: Record<string, any> = {
      'ward-status': {
        content: {
          health: 'Based on medical records, ward appears to be in good health.',
          wellbeing: 'School reports indicate positive social engagement.',
          activities: 'Participates in extracurricular activities regularly.',
        },
        isComplete: true,
        confidence: 85,
      },
      'financial-summary': {
        content: {
          income: 'KES 50,000 from rental property',
          expenses: 'KES 25,000 for school fees and maintenance',
          netChange: 'KES 25,000 positive',
        },
        isComplete: true,
        confidence: 90,
      },
      'educational-progress': {
        content: {
          performance: 'Above average in Mathematics and Sciences',
          attendance: '95% attendance rate',
          teacherFeedback: 'Consistent improvement noted',
        },
        isComplete: true,
        confidence: 80,
      },
    };

    const templateKey = sectionId.split('-')[0];
    return (
      templates[templateKey] || {
        content: 'Content generation failed. Please complete manually.',
        isComplete: false,
        confidence: 0,
      }
    );
  }

  // ðŸŽ¯ INNOVATIVE: Smart reminders system
  public addReminderEvent(reminder: ReminderEvent): void {
    const props = this.props as any;
    props.reminderHistory.push(reminder);

    // Auto-acknowledge if system-generated and no action needed
    if (reminder.type === 'SYSTEM' && !reminder.content.includes('action required')) {
      reminder.acknowledged = true;
      reminder.acknowledgedAt = new Date();
    }

    this.incrementVersion();
  }

  public addFollowUpAction(action: FollowUpAction): void {
    const props = this.props as any;
    props.followUpActions.push(action);
    this.incrementVersion();
  }

  // ðŸŽ¯ INNOVATIVE: Generate court-ready document
  public generateCourtDocument(format: 'PDF' | 'DOCX' | 'HTML' = 'PDF'): {
    content: string;
    metadata: Record<string, any>;
    validationStamp: string;
  } {
    if (
      this.props.status !== ComplianceStatus.ACCEPTED &&
      this.props.status !== ComplianceStatus.SUBMITTED
    ) {
      throw new Error('Only accepted or submitted reports can generate court documents');
    }

    const documentMetadata = {
      title: this.props.reportTitle,
      caseNumber: this.props.courtSubmission?.courtCaseNumber || 'N/A',
      year: this.props.year,
      period: this.props.reportingPeriod,
      generatedAt: new Date().toISOString(),
      complianceCheckId: this.id.toString(),
      qualityScore: this.props.qualityScore,
      validationStatus: this.props.validationStatus,
    };

    // Generate document based on format
    let content = '';
    switch (format) {
      case 'HTML':
        content = this.generateHTMLDocument();
        break;
      case 'DOCX':
        content = this.generateDOCXDocument();
        break;
      case 'PDF':
      default:
        content = this.generatePDFContent();
        break;
    }

    const validationStamp = this.generateValidationStamp();

    return {
      content,
      metadata: documentMetadata,
      validationStamp,
    };
  }

  private generateHTMLDocument(): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>${this.props.reportTitle}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { text-align: center; border-bottom: 2px solid #333; padding-bottom: 20px; }
        .section { margin: 30px 0; }
        .signature { margin-top: 50px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${this.props.reportTitle}</h1>
        <p>Year: ${this.props.year} | Period: ${this.props.reportingPeriod}</p>
        <p>Quality Score: ${this.props.qualityScore}/100</p>
    </div>
    ${this.props.sections
      .map(
        (section) => `
        <div class="section">
            <h2>${section.title}</h2>
            <pre>${JSON.stringify(section.content, null, 2)}</pre>
        </div>
    `,
      )
      .join('')}
    <div class="signature">
        <p>Generated: ${new Date().toLocaleDateString()}</p>
        <p>Validation Stamp: ${this.generateValidationStamp()}</p>
    </div>
</body>
</html>`;
  }

  private generateDOCXDocument(): string {
    // Simplified - real implementation would use a DOCX template
    return JSON.stringify(
      {
        title: this.props.reportTitle,
        sections: this.props.sections,
        metadata: {
          generatedAt: new Date().toISOString(),
          complianceCheckId: this.id.toString(),
        },
      },
      null,
      2,
    );
  }

  private generatePDFContent(): string {
    // Simplified - real implementation would generate actual PDF
    return `PDF_CONTENT:${this.id.toString()}:${Date.now()}`;
  }

  private generateValidationStamp(): string {
    const hashInput = `${this.id.toString()}:${this.props.year}:${this.props.reportingPeriod}:${this.props.qualityScore}`;
    // Simple hash simulation
    return Buffer.from(hashInput).toString('base64').substring(0, 20);
  }

  // ðŸŽ¯ INNOVATIVE: Calculate overdue penalties
  public calculatePenalty(): {
    amount: number;
    reason: string;
    waived: boolean;
    courtApprovalRequired: boolean;
  } {
    if (this.props.status !== ComplianceStatus.OVERDUE) {
      return { amount: 0, reason: 'Not overdue', waived: false, courtApprovalRequired: false };
    }

    const overdueDays = this.calculateOverdueDays();
    let penaltyAmount = 0;
    let reason = '';

    // Kenyan law: Typically KES 5,000 per month overdue
    if (overdueDays <= 30) {
      penaltyAmount = 5000;
      reason = 'Late submission (up to 30 days)';
    } else if (overdueDays <= 60) {
      penaltyAmount = 10000;
      reason = 'Late submission (31-60 days)';
    } else {
      penaltyAmount = 20000;
      reason = 'Late submission (over 60 days)';
    }

    // Check if waiver applies
    const waived = this.isWaiverApplicable();

    return {
      amount: waived ? 0 : penaltyAmount,
      reason,
      waived,
      courtApprovalRequired: overdueDays > 60,
    };
  }

  private calculateOverdueDays(): number {
    if (!this.props.submissionDeadline || this.props.status !== ComplianceStatus.OVERDUE) {
      return 0;
    }

    const today = new Date();
    const deadline = new Date(this.props.submissionDeadline);
    const diffTime = today.getTime() - deadline.getTime();
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  private isWaiverApplicable(): boolean {
    // Waiver conditions:
    // 1. Guardian was hospitalized
    // 2. Natural disaster
    // 3. Court strike
    // 4. First-time offender with good history
    return (
      this.props.notes?.toLowerCase().includes('hospital') ||
      this.props.notes?.toLowerCase().includes('emergency') ||
      this.hasGoodHistory()
    );
  }

  private hasGoodHistory(): boolean {
    // Simplified - real implementation would check previous compliance
    return this.props.qualityScore > 80;
  }

  // ðŸŽ¯ INNOVATIVE: Get compliance timeline
  public getTimeline(): Array<{
    date: Date;
    event: string;
    status: string;
    details?: string;
  }> {
    const timeline: Array<{
      date: Date;
      event: string;
      status: string;
      details?: string;
    }> = [];

    // Creation - use the Entity's created date
    timeline.push({
      date: this.createdAt,
      event: 'Compliance Check Created',
      status: 'CREATED',
      details: `Year: ${this.props.year}, Period: ${this.props.reportingPeriod}`,
    });

    // Due date
    timeline.push({
      date: this.props.dueDate,
      event: 'Due Date',
      status: 'DUE',
    });

    // Submission if exists
    if (this.props.submissionDate) {
      timeline.push({
        date: this.props.submissionDate,
        event: 'Report Submitted',
        status: 'SUBMITTED',
        details: `Method: ${this.props.submissionMethods[0]?.method}`,
      });
    }

    // Review if exists
    if (this.props.reviewedDate) {
      timeline.push({
        date: this.props.reviewedDate,
        event: 'Report Reviewed',
        status: 'REVIEWED',
        details: `By: ${this.props.reviewedBy}`,
      });
    }

    // Acceptance if exists
    if (this.props.acceptedDate) {
      timeline.push({
        date: this.props.acceptedDate,
        event: 'Report Accepted',
        status: 'ACCEPTED',
      });
    }

    // Sort by date
    timeline.sort((a, b) => a.date.getTime() - b.date.getTime());

    return timeline;
  }

  // Getters
  get status(): ComplianceStatus {
    return this.props.status;
  }

  get qualityScore(): number {
    return this.props.qualityScore;
  }

  get isOverdue(): boolean {
    return this.props.status === ComplianceStatus.OVERDUE;
  }

  get isComplete(): boolean {
    return this.props.sections.every((s) => !s.isRequired || s.isComplete);
  }

  // ðŸŽ¯ INNOVATIVE: Factory method
  public static create(
    props: Omit<
      ComplianceCheckProps,
      | 'status'
      | 'validationStatus'
      | 'validationErrors'
      | 'qualityScore'
      | 'generatedSections'
      | 'submissionMethods'
      | 'submissionReferences'
      | 'reminderHistory'
      | 'followUpActions'
    > & {
      id?: string;
    },
  ): ComplianceCheckEntity {
    const defaultProps: Partial<ComplianceCheckProps> = {
      status: ComplianceStatus.DRAFT,
      validationStatus: ValidationStatus.PENDING,
      validationErrors: [],
      qualityScore: 0,
      generatedSections: [],
      submissionMethods: [],
      submissionReferences: [],
      reminderHistory: [],
      followUpActions: [],
    };

    const entityProps: ComplianceCheckProps = {
      ...props,
      ...defaultProps,
    } as ComplianceCheckProps;

    return new ComplianceCheckEntity(new UniqueEntityID(props.id), entityProps);
  }
}
