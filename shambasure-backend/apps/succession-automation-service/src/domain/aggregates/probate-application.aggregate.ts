// src/succession-automation/src/domain/aggregates/probate-application.aggregate.ts
import { AggregateRoot } from '../base/aggregate-root';
import { DomainEvent } from '../base/domain-event';
import { UniqueEntityID } from '../base/unique-entity-id';
import { ConsentStatus, FamilyConsent } from '../entities/family-consent.entity';
import { FormStatus, GeneratedForm } from '../entities/generated-form.entity';
import {
  AllConsentsReceived,
  AllFormsGenerated,
  ApplicationAutoGenerated,
  ApplicationFiled,
  ApplicationReadyToFile,
  ApplicationWithdrawn,
  ConsentDeclined,
  ConsentGranted,
  ConsentRequested,
  ConsentWithdrawn,
  CourtRejectionReceived,
  FilingFeePaid,
  FormGenerated,
  FormsRegenerated,
  FormsReviewed,
  GrantIssued,
  ProbateApplicationCreated,
} from '../events/probate-application.events';
import { KenyanFormType, KenyanFormTypeEnum } from '../value-objects/kenyan-form-type.vo';
import { FilingConfidence, ReadinessScore } from '../value-objects/readiness-score.vo';
import { SuccessionContext, SuccessionRegime } from '../value-objects/succession-context.vo';

/**
 * Probate Application Aggregate Root
 *
 * PURPOSE: The "Bundle Generator" - compiles all legal documents for court filing.
 *
 * INNOVATION: Smart Form Strategy with Auto-Generation
 *
 * 1. Auto-Detection: Automatically detects which forms are needed based on SuccessionContext
 * 2. Dynamic Updates: Regenerates forms when context changes (e.g., Will discovered)
 * 3. Court-Specific: Different forms for High Court vs Kadhi's Court vs Magistrate
 * 4. Cost Calculation: Automatic filing fee calculation per court
 * 5. Timeline Prediction: Estimated processing times based on court and complexity
 *
 * AGGREGATE BOUNDARY:
 * - Root: ProbateApplication
 * - Entities: GeneratedForm[], FamilyConsent[]
 * - Value Objects: SuccessionContext, KenyanFormType, ReadinessScore
 *
 * INVARIANTS:
 * 1. Primary petition form must match application type (P&A 1 for TESTATE, P&A 80 for INTESTATE)
 * 2. All required consents must be GRANTED before filing
 * 3. All forms must be APPROVED and SIGNED before filing
 * 4. Filing fee must be paid before filing
 * 5. Cannot modify after filing (audit trail)
 * 6. Islamic cases must use Kadhi's Court forms
 */

export enum ProbateApplicationType {
  GRANT_OF_PROBATE = 'GRANT_OF_PROBATE', // P&A 1 (Testate - with Will)
  LETTERS_OF_ADMINISTRATION = 'LETTERS_OF_ADMINISTRATION', // P&A 80 (Intestate - no Will)
  LETTERS_OF_ADMIN_WILL_ANNEXED = 'LETTERS_OF_ADMIN_WILL_ANNEXED', // P&A 81 (Will with defects)
  SUMMARY_ADMINISTRATION = 'SUMMARY_ADMINISTRATION', // P&A 5 (Small estates < KES 500k)
  LIMITED_GRANT_AD_LITEM = 'LIMITED_GRANT_AD_LITEM', // Limited grant for specific purpose
  LIMITED_GRANT_COLLECTION = 'LIMITED_GRANT_COLLECTION', // Collect specific assets
  ISLAMIC_GRANT = 'ISLAMIC_GRANT', // Kadhi's Court
  CUSTOMARY_GRANT = 'CUSTOMARY_GRANT', // Customary law succession
}

export enum ApplicationStatus {
  DRAFT = 'DRAFT', // Initial creation, forms being generated
  PENDING_FORMS = 'PENDING_FORMS', // Forms generated, awaiting review
  UNDER_REVIEW = 'UNDER_REVIEW', // User reviewing forms
  PENDING_SIGNATURES = 'PENDING_SIGNATURES', // Forms approved, awaiting signatures
  PENDING_CONSENTS = 'PENDING_CONSENTS', // Waiting for family consents
  PENDING_FEE = 'PENDING_FEE', // Waiting for filing fee payment
  READY_TO_FILE = 'READY_TO_FILE', // All requirements met
  FILED = 'FILED', // Submitted to court registry
  COURT_REVIEW = 'COURT_REVIEW', // Under court review
  GAZETTE_PUBLISHED = 'GAZETTE_PUBLISHED', // Gazette notice published (30-day wait)
  GRANTED = 'GRANTED', // Court issued grant
  REJECTED = 'REJECTED', // Court rejected application
  AMENDMENT_REQUIRED = 'AMENDMENT_REQUIRED', // Court requires amendments
  WITHDRAWN = 'WITHDRAWN', // User withdrew application
  ABANDONED = 'ABANDONED', // Inactive for 90+ days
}

export enum FilingPriority {
  URGENT = 'URGENT', // Minors without support, disputed assets
  HIGH = 'HIGH', // Standard with deadlines
  NORMAL = 'NORMAL', // Regular succession
  LOW = 'LOW', // Simple, uncontested
}

export interface ProbateApplicationProps {
  // Identity & Context
  estateId: string;
  readinessAssessmentId: string; // Required link to ReadinessAssessment
  readinessScore?: ReadinessScore; // Current readiness score
  successionContext: SuccessionContext;
  applicationType: ProbateApplicationType;

  // Applicant & Executor
  applicantUserId: string;
  applicantFullName: string;
  applicantRelationship: string;
  applicantContact: {
    phone?: string;
    email?: string;
    physicalAddress?: string;
  };

  // Court Information
  targetCourtJurisdiction: string; // e.g., "HIGH_COURT", "KADHIS_COURT"
  targetCourtName: string; // e.g., "High Court of Kenya at Nairobi"
  courtStation: string;
  courtRegistry?: string; // Specific registry within court
  estimatedProcessingDays?: number; // Based on court and complexity

  // Status & Timeline
  status: ApplicationStatus;
  priority: FilingPriority;
  createdAt: Date;
  estimatedFilingDate?: Date;
  estimatedGrantDate?: Date;

  // Generated Forms (Collection)
  forms: GeneratedForm[];

  // Family Consents (Collection)
  consents: FamilyConsent[];

  // Filing Information
  filedAt?: Date;
  filingMethod?: 'E_FILING' | 'PHYSICAL' | 'COURT_REGISTRY';
  courtCaseNumber?: string;
  courtFileNumber?: string;
  courtReceiptNumber?: string;
  filingFeeAmount?: number;
  filingFeePaid: boolean;
  filingFeePaidAt?: Date;

  // Court Response & Gazette
  courtReviewDate?: Date;
  gazettePublishedDate?: Date;
  gazetteNoticeId?: string;
  objectionDeadline?: Date; // 30 days after gazette

  // Grant Information
  grantedDate?: Date;
  grantNumber?: string;
  grantType?: string; // "Grant of Probate", "Letters of Administration"
  grantIssuedBy?: string; // Registrar name

  // Rejection/Amendment
  rejectionReason?: string;
  rejectionDate?: Date;
  amendmentsRequired?: string[];
  amendmentDeadline?: Date;

  // Withdrawal
  withdrawnAt?: Date;
  withdrawalReason?: string;

  // Statistics & Analytics
  totalFormsGenerated: number;
  totalConsentsRequired: number;
  daysInCurrentStatus: number;
  lastStatusChangeAt: Date;

  // Metadata
  lastReviewedAt?: Date;
  lastReviewedBy?: string;
  notes?: string;
  internalNotes?: string;
  version: number; // Application version for tracking changes
}

export class ProbateApplication extends AggregateRoot<ProbateApplicationProps> {
  // Status transition rules
  private static readonly ALLOWED_TRANSITIONS: Record<ApplicationStatus, ApplicationStatus[]> = {
    [ApplicationStatus.DRAFT]: [
      ApplicationStatus.PENDING_FORMS,
      ApplicationStatus.WITHDRAWN,
      ApplicationStatus.ABANDONED,
    ],
    [ApplicationStatus.PENDING_FORMS]: [
      ApplicationStatus.UNDER_REVIEW,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.UNDER_REVIEW]: [
      ApplicationStatus.PENDING_SIGNATURES,
      ApplicationStatus.PENDING_FORMS,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.PENDING_SIGNATURES]: [
      ApplicationStatus.PENDING_CONSENTS,
      ApplicationStatus.UNDER_REVIEW,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.PENDING_CONSENTS]: [
      ApplicationStatus.PENDING_FEE,
      ApplicationStatus.PENDING_SIGNATURES,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.PENDING_FEE]: [
      ApplicationStatus.READY_TO_FILE,
      ApplicationStatus.PENDING_CONSENTS,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.READY_TO_FILE]: [
      ApplicationStatus.FILED,
      ApplicationStatus.PENDING_FEE,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.FILED]: [
      ApplicationStatus.COURT_REVIEW,
      ApplicationStatus.AMENDMENT_REQUIRED,
      ApplicationStatus.REJECTED,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.COURT_REVIEW]: [
      ApplicationStatus.GAZETTE_PUBLISHED,
      ApplicationStatus.AMENDMENT_REQUIRED,
      ApplicationStatus.REJECTED,
    ],
    [ApplicationStatus.GAZETTE_PUBLISHED]: [
      ApplicationStatus.GRANTED,
      ApplicationStatus.AMENDMENT_REQUIRED,
      ApplicationStatus.REJECTED,
    ],
    [ApplicationStatus.GRANTED]: [], // Terminal state
    [ApplicationStatus.REJECTED]: [
      ApplicationStatus.AMENDMENT_REQUIRED,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.AMENDMENT_REQUIRED]: [
      ApplicationStatus.UNDER_REVIEW,
      ApplicationStatus.WITHDRAWN,
    ],
    [ApplicationStatus.WITHDRAWN]: [], // Terminal state
    [ApplicationStatus.ABANDONED]: [ApplicationStatus.WITHDRAWN],
  };

  private constructor(id: UniqueEntityID, props: ProbateApplicationProps, createdAt?: Date) {
    super(id, props, createdAt);
  }

  // ==================== GETTERS ====================

  get estateId(): string {
    return this.props.estateId;
  }

  get readinessAssessmentId(): string {
    return this.props.readinessAssessmentId;
  }

  get readinessScore(): ReadinessScore | undefined {
    return this.props.readinessScore;
  }

  get successionContext(): SuccessionContext {
    return this.props.successionContext;
  }

  get applicationType(): ProbateApplicationType {
    return this.props.applicationType;
  }

  get applicantUserId(): string {
    return this.props.applicantUserId;
  }

  get targetCourtJurisdiction(): string {
    return this.props.targetCourtJurisdiction;
  }

  get targetCourtName(): string {
    return this.props.targetCourtName;
  }

  get status(): ApplicationStatus {
    return this.props.status;
  }

  get priority(): FilingPriority {
    return this.props.priority;
  }

  get forms(): ReadonlyArray<GeneratedForm> {
    return Object.freeze([...this.props.forms]);
  }

  get consents(): ReadonlyArray<FamilyConsent> {
    return Object.freeze([...this.props.consents]);
  }

  get filedAt(): Date | undefined {
    return this.props.filedAt;
  }

  get courtCaseNumber(): string | undefined {
    return this.props.courtCaseNumber;
  }
  get version(): number {
    return this.props.version;
  }
  get filingFeePaid(): boolean {
    return this.props.filingFeePaid;
  }

  get grantNumber(): string | undefined {
    return this.props.grantNumber;
  }

  get totalFormsGenerated(): number {
    return this.props.totalFormsGenerated;
  }

  get totalConsentsRequired(): number {
    return this.props.totalConsentsRequired;
  }

  // ==================== DERIVED PROPERTIES ====================

  /**
   * Get primary petition form (P&A 1, P&A 5, P&A 80, or Islamic)
   */
  public getPrimaryPetitionForm(): GeneratedForm | undefined {
    return this.props.forms.find((form) => {
      const formType = form.formType;
      return (
        formType === KenyanFormTypeEnum.PA1_PETITION ||
        formType === KenyanFormTypeEnum.PA5_PETITION_SUMMARY ||
        formType === KenyanFormTypeEnum.PA80_PETITION_INTESTATE ||
        formType === KenyanFormTypeEnum.ISLAMIC_PETITION
      );
    });
  }

  /**
   * Get all approved forms
   */
  public getApprovedForms(): GeneratedForm[] {
    return this.props.forms.filter(
      (form) => form.status === FormStatus.APPROVED || form.status === FormStatus.SIGNED,
    );
  }

  /**
   * Get all pending forms
   */
  public getPendingForms(): GeneratedForm[] {
    return this.props.forms.filter(
      (form) => form.status === FormStatus.GENERATED || form.status === FormStatus.UNDER_REVIEW,
    );
  }

  /**
   * Get forms requiring signatures
   */
  public getFormsRequiringSignatures(): GeneratedForm[] {
    return this.props.forms.filter((form) => form.needsSignatures());
  }

  /**
   * Get granted consents
   */
  public getGrantedConsents(): FamilyConsent[] {
    return this.props.consents.filter((consent) => consent.isGranted());
  }

  /**
   * Get pending consents
   */
  public getPendingConsents(): FamilyConsent[] {
    return this.props.consents.filter((consent) => consent.isPending());
  }

  /**
   * Get declined consents
   */
  public getDeclinedConsents(): FamilyConsent[] {
    return this.props.consents.filter((consent) => consent.isDeclined());
  }

  /**
   * Get required consents (excluding NOT_REQUIRED)
   */
  public getRequiredConsents(): FamilyConsent[] {
    return this.props.consents.filter((consent) => consent.isRequired());
  }

  /**
   * Are all forms ready for filing?
   */
  public areAllFormsReady(): boolean {
    if (this.props.forms.length === 0) return false;

    return this.props.forms.every((form) => form.canBeFiled() || form.status === FormStatus.SIGNED);
  }

  /**
   * Are all required consents received?
   */
  public areAllConsentsReceived(): boolean {
    const requiredConsents = this.getRequiredConsents();
    if (requiredConsents.length === 0) return true;

    return requiredConsents.every((consent) => consent.isGranted());
  }

  /**
   * Has any consent been declined?
   */
  public hasDeclinedConsent(): boolean {
    return this.props.consents.some((consent) => consent.isDeclined());
  }

  /**
   * Has any consent been withdrawn?
   */
  public hasWithdrawnConsent(): boolean {
    return this.props.consents.some((consent) => consent.status === ConsentStatus.WITHDRAWN);
  }

  /**
   * Calculate total filing fees
   */
  public calculateTotalFilingFees(): number {
    let total = 0;

    // Base court fees based on jurisdiction
    const jurisdictionFees: Record<string, number> = {
      HIGH_COURT: 1000,
      MAGISTRATE_COURT: 500,
      KADHIS_COURT: 750,
      FAMILY_DIVISION: 1200,
    };

    total += jurisdictionFees[this.props.targetCourtJurisdiction] || 1000;

    // Add form-specific fees
    this.props.forms.forEach((form) => {
      // Each form might have its own fee
      // In production, would fetch from KenyanFormType VO
      if (
        form.formType === KenyanFormTypeEnum.PA1_PETITION ||
        form.formType === KenyanFormTypeEnum.PA80_PETITION_INTESTATE
      ) {
        total += 500; // Additional petition fee
      }
    });

    // Gazette publication fee
    total += 2000; // Standard gazette fee

    return total;
  }

  /**
   * Get estimated processing timeline
   */
  public getEstimatedTimeline(): {
    filing: Date;
    gazette: Date;
    grant: Date;
  } {
    const filingDate = this.props.filedAt || new Date();
    const gazetteDate = new Date(filingDate);
    gazetteDate.setDate(gazetteDate.getDate() + 14); // ~2 weeks for gazette

    const grantDate = new Date(gazetteDate);
    grantDate.setDate(grantDate.getDate() + 45); // ~45 days after gazette (30+15)

    return { filing: filingDate, gazette: gazetteDate, grant: grantDate };
  }

  /**
   * Can this application be filed?
   */
  public canFile(): boolean {
    // Check status
    if (this.props.status !== ApplicationStatus.READY_TO_FILE) {
      return false;
    }

    // Check forms
    if (!this.areAllFormsReady()) {
      return false;
    }

    // Check consents
    if (!this.areAllConsentsReceived()) {
      return false;
    }

    // Check for declined/withdrawn consents
    if (this.hasDeclinedConsent() || this.hasWithdrawnConsent()) {
      return false;
    }

    // Check filing fee
    if (!this.props.filingFeePaid) {
      return false;
    }

    // Must have at least one form
    if (this.props.forms.length === 0) {
      return false;
    }

    return true;
  }

  /**
   * Has this application been filed?
   */
  public isFiled(): boolean {
    return [
      ApplicationStatus.FILED,
      ApplicationStatus.COURT_REVIEW,
      ApplicationStatus.GAZETTE_PUBLISHED,
      ApplicationStatus.GRANTED,
      ApplicationStatus.AMENDMENT_REQUIRED,
      ApplicationStatus.REJECTED,
    ].includes(this.props.status);
  }

  /**
   * Is this application editable?
   */
  public isEditable(): boolean {
    return !this.isFiled() && this.props.status !== ApplicationStatus.GRANTED;
  }

  /**
   * Get progress percentage (for UI)
   */
  public getProgressPercentage(): number {
    const steps = {
      formsGenerated: 25,
      formsReviewed: 25,
      consentsReceived: 25,
      feePaid: 15,
      filed: 10,
    };

    let progress = 0;

    // Forms generated
    if (this.props.forms.length > 0) {
      progress += steps.formsGenerated;
    }

    // Forms reviewed/approved
    if (this.getApprovedForms().length === this.props.forms.length) {
      progress += steps.formsReviewed;
    }

    // Consents received
    if (this.areAllConsentsReceived()) {
      progress += steps.consentsReceived;
    }

    // Fee paid
    if (this.props.filingFeePaid) {
      progress += steps.feePaid;
    }

    // Filed
    if (this.isFiled()) {
      progress += steps.filed;
    }

    return Math.min(100, progress);
  }

  /**
   * Get next required action
   */
  public getNextAction(): string {
    switch (this.props.status) {
      case ApplicationStatus.DRAFT:
        return 'Generate forms using Form Strategy';
      case ApplicationStatus.PENDING_FORMS:
        return 'Review generated forms';
      case ApplicationStatus.UNDER_REVIEW:
        return 'Approve forms to proceed to signatures';
      case ApplicationStatus.PENDING_SIGNATURES:
        return 'Obtain required signatures on forms';
      case ApplicationStatus.PENDING_CONSENTS:
        return 'Request consents from family members';
      case ApplicationStatus.PENDING_FEE:
        return 'Pay filing fees';
      case ApplicationStatus.READY_TO_FILE:
        return 'File application with court';
      case ApplicationStatus.FILED:
        return 'Wait for court review';
      case ApplicationStatus.COURT_REVIEW:
        return 'Wait for gazette publication';
      case ApplicationStatus.GAZETTE_PUBLISHED:
        return 'Wait for grant issuance';
      case ApplicationStatus.AMENDMENT_REQUIRED:
        return 'Make required amendments';
      default:
        return 'No action required';
    }
  }

  // ==================== BUSINESS LOGIC - FORMS ====================

  /**
   * Generate forms based on succession context
   * Uses FormStrategyService logic internally
   */
  public generateForms(estateValue: number): GeneratedForm[] {
    this.ensureNotDeleted();
    this.ensureEditable();

    // Determine forms based on context
    const formBundle = KenyanFormType.generateFormBundle(
      this.props.successionContext,
      estateValue,
      [], // Available prerequisites would come from readiness assessment
    );

    const generatedForms: GeneratedForm[] = [];

    // Create GeneratedForm entities for each form
    formBundle.forEach((formType) => {
      const form = GeneratedForm.createPending(
        formType.formType,
        formType.formCode,
        formType.displayName,
        0, // Default no signatures
        'system',
        formType.version,
        'succession-automation',
        `hash-${Date.now()}`,
      );

      generatedForms.push(form);

      // Add to aggregate
      this.addGeneratedForm(form);
    });

    // Update status
    if (generatedForms.length > 0) {
      this.updateStatus(ApplicationStatus.PENDING_FORMS);
    }

    return generatedForms;
  }

  /**
   * Add a generated form
   */
  public addGeneratedForm(form: GeneratedForm): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    // Check for duplicate form type (excluding superseded)
    const existingForm = this.props.forms.find(
      (f) => f.formType === form.formType && f.status !== FormStatus.SUPERSEDED,
    );

    if (existingForm) {
      throw new Error(
        `Form type ${form.formCode} already exists. Use supersedeForm() to replace it.`,
      );
    }

    const updatedForms = [...this.props.forms, form];

    this.updateState({
      forms: updatedForms,
      totalFormsGenerated: this.props.totalFormsGenerated + 1,
    });

    // Emit event
    this.addDomainEvent(
      new FormGenerated(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        formId: form.id.toString(),
        formType: form.formType,
        formCode: form.formCode,
      }),
    );

    // Check if all forms generated
    this.checkFormsCompletion();
  }

  /**
   * Regenerate all forms (e.g., when context changes)
   */
  public regenerateForms(estateValue: number): GeneratedForm[] {
    this.ensureNotDeleted();
    this.ensureEditable();

    // Mark existing forms as superseded
    this.props.forms.forEach((form) => {
      if (form.status !== FormStatus.SUPERSEDED) {
        // In production, would create FormSuperseded event for each
      }
    });

    // Clear forms and regenerate
    this.updateState({ forms: [] });
    const newForms = this.generateForms(estateValue);

    // Emit regeneration event
    this.addDomainEvent(
      new FormsRegenerated(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        totalForms: newForms.length,
        reason: 'Succession context changed',
      }),
    );

    return newForms;
  }

  /**
   * Approve a specific form
   */
  public approveForm(formId: string, approvedBy: string, notes?: string): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    const form = this.props.forms.find((f) => f.id.equals(formId));
    if (!form) {
      throw new Error(`Form ${formId} not found`);
    }

    form.approve(approvedBy, notes);

    // Check if all forms approved
    this.checkFormsCompletion();
  }

  /**
   * Approve all pending forms
   */
  public approveAllForms(approvedBy: string): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    const pendingForms = this.getPendingForms();
    if (pendingForms.length === 0) {
      throw new Error('No forms to approve');
    }

    pendingForms.forEach((form) => {
      form.approve(approvedBy, 'Bulk approval');
    });

    // Update status
    this.updateStatus(ApplicationStatus.PENDING_SIGNATURES);

    // Emit event
    this.addDomainEvent(
      new FormsReviewed(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        reviewedBy: approvedBy,
        totalForms: pendingForms.length,
      }),
    );
  }

  // ==================== BUSINESS LOGIC - CONSENTS ====================

  /**
   * Add consent request for family member
   */
  public addConsentRequest(consent: FamilyConsent): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    // Check for duplicate family member
    const existingConsent = this.props.consents.find(
      (c) => c.familyMemberId === consent.familyMemberId,
    );

    if (existingConsent) {
      throw new Error(`Consent already exists for family member ${consent.familyMemberId}`);
    }

    const updatedConsents = [...this.props.consents, consent];

    this.updateState({
      consents: updatedConsents,
      totalConsentsRequired: this.getRequiredConsents().length,
    });
  }

  /**
   * Send consent request to family member
   */
  public sendConsentRequest(consentId: string, method: 'SMS' | 'EMAIL' | 'BOTH'): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    const consent = this.props.consents.find((c) => c.id.equals(consentId));
    if (!consent) {
      throw new Error(`Consent ${consentId} not found`);
    }

    consent.sendConsentRequest(method);

    // Emit event
    this.addDomainEvent(
      new ConsentRequested(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        consentId: consent.id.toString(),
        familyMemberId: consent.familyMemberId,
        familyMemberName: consent.fullName,
        method,
      }),
    );
  }

  /**
   * Record consent granted
   */
  public recordConsentGranted(consentId: string, method: string): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    const consent = this.props.consents.find((c) => c.id.equals(consentId));
    if (!consent) {
      throw new Error(`Consent ${consentId} not found`);
    }

    consent.grantConsent(method as any);

    // Emit event
    this.addDomainEvent(
      new ConsentGranted(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        consentId: consent.id.toString(),
        familyMemberId: consent.familyMemberId,
        familyMemberName: consent.fullName,
        method,
      }),
    );

    // Check if all consents received
    this.checkConsentsCompletion();
  }

  /**
   * Record consent declined
   */
  public recordConsentDeclined(
    consentId: string,
    reason: string,
    category: 'DISPUTE' | 'NOT_INFORMED' | 'DISAGREE_WITH_DISTRIBUTION' | 'OTHER',
  ): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    const consent = this.props.consents.find((c) => c.id.equals(consentId));
    if (!consent) {
      throw new Error(`Consent ${consentId} not found`);
    }

    consent.declineConsent(reason, category);

    // Emit event
    this.addDomainEvent(
      new ConsentDeclined(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        consentId: consent.id.toString(),
        familyMemberId: consent.familyMemberId,
        familyMemberName: consent.fullName,
        reason,
        category,
      }),
    );
  }

  /**
   * Record consent withdrawn
   */
  public recordConsentWithdrawn(consentId: string, reason: string): void {
    this.ensureNotDeleted();

    const consent = this.props.consents.find((c) => c.id.equals(consentId));
    if (!consent) {
      throw new Error(`Consent ${consentId} not found`);
    }

    consent.withdrawConsent(reason);

    // Emit event
    this.addDomainEvent(
      new ConsentWithdrawn(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        consentId: consent.id.toString(),
        familyMemberId: consent.familyMemberId,
        familyMemberName: consent.fullName,
        reason,
      }),
    );

    // Update application status if needed
    if (this.props.status === ApplicationStatus.READY_TO_FILE) {
      this.updateStatus(ApplicationStatus.PENDING_CONSENTS);
    }
  }

  // ==================== BUSINESS LOGIC - FILING ====================

  /**
   * Mark filing fee as paid
   */
  public markFilingFeePaid(amount: number, paymentMethod: string, receiptNumber?: string): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    this.updateState({
      filingFeePaid: true,
      filingFeeAmount: amount,
      filingFeePaidAt: new Date(),
    });

    // Emit event
    this.addDomainEvent(
      new FilingFeePaid(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        amount,
        paymentMethod,
        receiptNumber,
        paidAt: new Date(),
      }),
    );

    // Check if ready to file
    this.checkReadinessToFile();
  }

  /**
   * File application with court
   */
  public fileWithCourt(
    filingMethod: 'E_FILING' | 'PHYSICAL' | 'COURT_REGISTRY',
    courtCaseNumber?: string,
    courtReceiptNumber?: string,
    filingReference?: string,
  ): void {
    this.ensureNotDeleted();
    this.ensureEditable();

    if (!this.canFile()) {
      throw new Error(
        'Cannot file application. Requirements not met:\n' +
          `- Status must be READY_TO_FILE (current: ${this.props.status})\n` +
          `- All forms ready: ${this.areAllFormsReady()}\n` +
          `- All consents received: ${this.areAllConsentsReceived()}\n` +
          `- No declined consents: ${!this.hasDeclinedConsent()}\n` +
          `- Filing fee paid: ${this.props.filingFeePaid}`,
      );
    }

    // Generate a temporary case number if not provided
    const finalCourtCaseNumber = courtCaseNumber || `TEMP-${Date.now()}-${this.id.toString()}`;

    // Mark forms as filed
    this.props.forms.forEach((form) => {
      if (form.canBeFiled()) {
        form.markAsFiled(finalCourtCaseNumber, filingReference || `REF-${Date.now()}`);
      }
    });

    this.updateState({
      status: ApplicationStatus.FILED,
      filedAt: new Date(),
      filingMethod,
      courtCaseNumber: finalCourtCaseNumber,
      courtReceiptNumber,
      lastStatusChangeAt: new Date(),
    });

    // Emit event with the final court case number
    this.addDomainEvent(
      new ApplicationFiled(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        courtCaseNumber: finalCourtCaseNumber, // Now guaranteed to be a string
        courtStation: this.props.courtStation,
        filingMethod,
        filedAt: new Date(),
      }),
    );
  }

  /**
   * Record court rejection
   */
  public recordCourtRejection(reason: string, amendmentsRequired?: string[]): void {
    this.ensureNotDeleted();

    if (!this.isFiled()) {
      throw new Error('Can only reject filed applications');
    }

    this.updateState({
      status: ApplicationStatus.REJECTED,
      rejectionReason: reason,
      rejectionDate: new Date(),
      amendmentsRequired,
      amendmentDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
      lastStatusChangeAt: new Date(),
    });

    // Emit event
    this.addDomainEvent(
      new CourtRejectionReceived(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        reason,
        amendmentsRequired,
        rejectedAt: new Date(),
      }),
    );
  }

  /**
   * Record grant issuance
   */
  public recordGrantIssued(grantNumber: string, grantType: string, issuedBy: string): void {
    this.ensureNotDeleted();

    if (this.props.status !== ApplicationStatus.GAZETTE_PUBLISHED) {
      throw new Error('Can only issue grant after gazette publication');
    }

    this.updateState({
      status: ApplicationStatus.GRANTED,
      grantedDate: new Date(),
      grantNumber,
      grantType,
      grantIssuedBy: issuedBy,
      lastStatusChangeAt: new Date(),
    });

    // Emit event
    this.addDomainEvent(
      new GrantIssued(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        grantNumber,
        grantType,
        issuedBy,
        issuedAt: new Date(),
      }),
    );
  }

  /**
   * Record gazette publication
   */
  public recordGazettePublished(gazetteNoticeId: string): void {
    this.ensureNotDeleted();

    if (this.props.status !== ApplicationStatus.COURT_REVIEW) {
      throw new Error('Can only publish gazette after court review');
    }

    const objectionDeadline = new Date();
    objectionDeadline.setDate(objectionDeadline.getDate() + 30); // 30-day objection period

    this.updateState({
      status: ApplicationStatus.GAZETTE_PUBLISHED,
      gazettePublishedDate: new Date(),
      gazetteNoticeId,
      objectionDeadline,
      lastStatusChangeAt: new Date(),
    });
  }

  /**
   * Withdraw application
   */
  public withdrawApplication(reason: string): void {
    this.ensureNotDeleted();

    if (this.props.status === ApplicationStatus.GRANTED) {
      throw new Error('Cannot withdraw granted application');
    }

    this.updateState({
      status: ApplicationStatus.WITHDRAWN,
      withdrawnAt: new Date(),
      withdrawalReason: reason,
      lastStatusChangeAt: new Date(),
    });

    // Emit event
    this.addDomainEvent(
      new ApplicationWithdrawn(this.id.toString(), this.getAggregateType(), this.getVersion(), {
        applicationId: this.id.toString(),
        estateId: this.props.estateId,
        reason,
        withdrawnAt: new Date(),
      }),
    );
  }

  // ==================== PRIVATE HELPERS ====================

  /**
   * Update status with validation
   */
  private updateStatus(newStatus: ApplicationStatus): void {
    const allowedTransitions = ProbateApplication.ALLOWED_TRANSITIONS[this.props.status] || [];

    if (!allowedTransitions.includes(newStatus) && newStatus !== this.props.status) {
      throw new Error(
        `Invalid status transition from ${this.props.status} to ${newStatus}. ` +
          `Allowed transitions: ${allowedTransitions.join(', ')}`,
      );
    }

    this.updateState({
      status: newStatus,
      lastStatusChangeAt: new Date(),
    });
  }

  /**
   * Check if all forms are completed
   */
  private checkFormsCompletion(): void {
    if (this.props.forms.length === 0) return;

    const allFormsApproved = this.props.forms.every(
      (form) => form.status === FormStatus.APPROVED || form.status === FormStatus.SIGNED,
    );

    if (allFormsApproved && this.props.status === ApplicationStatus.PENDING_FORMS) {
      this.updateStatus(ApplicationStatus.PENDING_SIGNATURES);

      // Emit event
      this.addDomainEvent(
        new AllFormsGenerated(this.id.toString(), this.getAggregateType(), this.getVersion(), {
          applicationId: this.id.toString(),
          estateId: this.props.estateId,
          totalForms: this.props.forms.length,
        }),
      );
    }
  }

  /**
   * Check if all consents are received
   */
  private checkConsentsCompletion(): void {
    if (this.areAllConsentsReceived() && this.props.status === ApplicationStatus.PENDING_CONSENTS) {
      this.updateStatus(ApplicationStatus.PENDING_FEE);

      // Emit event
      this.addDomainEvent(
        new AllConsentsReceived(this.id.toString(), this.getAggregateType(), this.getVersion(), {
          applicationId: this.id.toString(),
          estateId: this.props.estateId,
          totalConsents: this.getRequiredConsents().length,
        }),
      );
    }
  }

  /**
   * Check if ready to file
   */
  private checkReadinessToFile(): void {
    if (this.canFile()) {
      this.updateStatus(ApplicationStatus.READY_TO_FILE);

      // Emit event
      this.addDomainEvent(
        new ApplicationReadyToFile(this.id.toString(), this.getAggregateType(), this.getVersion(), {
          applicationId: this.id.toString(),
          estateId: this.props.estateId,
          canFile: true,
          checkedAt: new Date(),
        }),
      );
    }
  }

  /**
   * Ensure application is editable
   */
  private ensureEditable(): void {
    if (!this.isEditable()) {
      throw new Error(`Cannot modify application with status ${this.props.status}`);
    }
  }

  // ==================== VALIDATION ====================

  public validate(): void {
    // INVARIANT 1: Must have forms if not in DRAFT or WITHDRAWN
    if (
      this.props.forms.length === 0 &&
      ![ApplicationStatus.DRAFT, ApplicationStatus.WITHDRAWN, ApplicationStatus.ABANDONED].includes(
        this.props.status,
      )
    ) {
      throw new Error('Application must have at least one form');
    }

    // INVARIANT 2: Application type must match succession context
    this.validateApplicationType();

    // INVARIANT 3: Court jurisdiction must match succession context
    this.validateCourtJurisdiction();

    // INVARIANT 4: READY_TO_FILE status requires all conditions
    if (this.props.status === ApplicationStatus.READY_TO_FILE) {
      if (!this.areAllConsentsReceived()) {
        throw new Error('All required consents must be granted');
      }
      if (!this.areAllFormsReady()) {
        throw new Error('All forms must be ready');
      }
      if (!this.props.filingFeePaid) {
        throw new Error('Filing fee must be paid');
      }
      if (this.hasDeclinedConsent()) {
        throw new Error('Cannot be ready with declined consents');
      }
    }

    // INVARIANT 5: Filed applications must have filing info
    if (this.isFiled() && !this.props.filedAt) {
      throw new Error('Filed application must have filedAt timestamp');
    }

    // INVARIANT 6: Granted applications must have grant info
    if (this.props.status === ApplicationStatus.GRANTED && !this.props.grantNumber) {
      throw new Error('Granted application must have grant number');
    }
  }

  /**
   * Validate application type matches succession context
   */
  private validateApplicationType(): void {
    const { successionContext, applicationType } = this.props;

    if (
      successionContext.requiresKadhisCourt() &&
      applicationType !== ProbateApplicationType.ISLAMIC_GRANT
    ) {
      throw new Error('Islamic cases must use ISLAMIC_GRANT application type');
    }

    if (
      successionContext.regime === SuccessionRegime.TESTATE &&
      applicationType !== ProbateApplicationType.GRANT_OF_PROBATE &&
      applicationType !== ProbateApplicationType.LETTERS_OF_ADMIN_WILL_ANNEXED
    ) {
      throw new Error('Testate cases must use GRANT_OF_PROBATE or LETTERS_OF_ADMIN_WILL_ANNEXED');
    }

    if (
      successionContext.regime === SuccessionRegime.INTESTATE &&
      applicationType !== ProbateApplicationType.LETTERS_OF_ADMINISTRATION &&
      applicationType !== ProbateApplicationType.SUMMARY_ADMINISTRATION
    ) {
      throw new Error(
        'Intestate cases must use LETTERS_OF_ADMINISTRATION or SUMMARY_ADMINISTRATION',
      );
    }
  }

  /**
   * Validate court jurisdiction matches succession context
   */
  private validateCourtJurisdiction(): void {
    const { successionContext, targetCourtJurisdiction } = this.props;

    if (successionContext.requiresKadhisCourt() && targetCourtJurisdiction !== 'KADHIS_COURT') {
      throw new Error("Islamic cases must be filed in Kadhi's Court");
    }

    // Add more jurisdiction validation as needed
  }

  // ==================== EVENT SOURCING ====================

  protected applyEvent(event: DomainEvent): void {
    // Event replay logic for rebuilding state
    // This would handle events when replaying from event store
    switch (event.getEventType()) {
      case 'ProbateApplicationCreated':
      case 'FormGenerated':
      case 'ConsentRequested':
      case 'ConsentGranted':
      case 'ApplicationFiled':
        // State already updated via business logic methods
        break;
      default:
        // Handle other events if needed
        break;
    }
  }

  // ==================== FACTORY METHODS ====================

  /**
   * Create a new probate application
   */
  public static create(
    estateId: string,
    readinessAssessmentId: string,
    successionContext: SuccessionContext,
    applicationType: ProbateApplicationType,
    applicantUserId: string,
    applicantFullName: string,
    applicantRelationship: string,
    applicantContact: { phone?: string; email?: string; physicalAddress?: string },
    targetCourtJurisdiction: string,
    targetCourtName: string,
    courtStation: string,
    priority: FilingPriority = FilingPriority.NORMAL,
  ): ProbateApplication {
    const id = UniqueEntityID.newID();
    const now = new Date();

    const application = new ProbateApplication(id, {
      estateId,
      readinessAssessmentId,
      successionContext,
      applicationType,
      applicantUserId,
      applicantFullName,
      applicantRelationship,
      applicantContact,
      targetCourtJurisdiction,
      targetCourtName,
      courtStation,
      status: ApplicationStatus.DRAFT,
      priority,
      createdAt: now,
      forms: [],
      consents: [],
      filingFeePaid: false,
      totalFormsGenerated: 0,
      totalConsentsRequired: 0,
      daysInCurrentStatus: 0,
      lastStatusChangeAt: now,
      version: 1,
    });

    // Emit creation event
    application.addDomainEvent(
      new ProbateApplicationCreated(id.toString(), application.getAggregateType(), 1, {
        applicationId: id.toString(),
        estateId,
        readinessAssessmentId,
        applicationType,
        targetCourt: targetCourtName,
        courtStation,
        createdAt: now,
      }),
    );

    return application;
  }

  /**
   * Auto-generate application based on readiness assessment
   */
  public static autoGenerate(
    estateId: string,
    readinessAssessmentId: string,
    readinessScore: ReadinessScore,
    successionContext: SuccessionContext,
    applicantUserId: string,
    applicantFullName: string,
    applicantRelationship: string,
    applicantContact: { phone?: string; email?: string; physicalAddress?: string },
  ): ProbateApplication {
    // Determine application type based on context
    let applicationType: ProbateApplicationType;

    if (successionContext.requiresKadhisCourt()) {
      applicationType = ProbateApplicationType.ISLAMIC_GRANT;
    } else if (successionContext.regime === SuccessionRegime.TESTATE) {
      applicationType = ProbateApplicationType.GRANT_OF_PROBATE;
    } else {
      applicationType = ProbateApplicationType.LETTERS_OF_ADMINISTRATION;
    }

    // Determine court jurisdiction
    const courtJurisdiction = successionContext.determineCourtJurisdiction();
    const targetCourtName = `${courtJurisdiction} - ${successionContext.toCaseClassification()}`;

    // Determine priority
    let priority = FilingPriority.NORMAL;
    if (readinessScore.isBlocked()) {
      priority = FilingPriority.URGENT;
    } else if (readinessScore.filingConfidence === FilingConfidence.HIGH) {
      priority = FilingPriority.HIGH;
    }

    const application = ProbateApplication.create(
      estateId,
      readinessAssessmentId,
      successionContext,
      applicationType,
      applicantUserId,
      applicantFullName,
      applicantRelationship,
      applicantContact,
      courtJurisdiction,
      targetCourtName,
      'Nairobi', // Default station
      priority,
    );

    // Set readiness score
    application.updateState({ readinessScore });

    // Emit auto-generation event
    application.addDomainEvent(
      new ApplicationAutoGenerated(application.id.toString(), application.getAggregateType(), 1, {
        applicationId: application.id.toString(),
        estateId,
        readinessScore: readinessScore.score,
        applicationType,
        autoGeneratedAt: new Date(),
      }),
    );

    return application;
  }

  /**
   * Reconstitute from persistence
   */
  public static reconstitute(
    id: string,
    props: ProbateApplicationProps,
    createdAt: Date,
    updatedAt: Date,
    version: number,
  ): ProbateApplication {
    const aggregate = new ProbateApplication(new UniqueEntityID(id), props, createdAt);
    (aggregate as any)._updatedAt = updatedAt;
    (aggregate as any)._version = version;
    return aggregate;
  }
}
