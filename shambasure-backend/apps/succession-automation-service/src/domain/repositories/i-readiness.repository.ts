// src/succession-automation/src/domain/repositories/i-readiness.repository.ts
import { ReadinessAssessment } from '../aggregates/readiness-assessment.aggregate';
import { RiskCategory } from '../entities/risk-flag.entity';
import { ReadinessStatus } from '../value-objects/readiness-score.vo';

export const READINESS_ASSESSMENT_REPOSITORY = 'READINESS_ASSESSMENT_REPOSITORY';

/**
 * Standard Pagination Options
 */
export interface RepositoryQueryOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Paginated Result Wrapper
 */
export interface PaginatedResult<T> {
  items: T[];
  total: number;
  page: number;
  pages: number;
  limit: number;
}

export interface IReadinessRepository {
  // ==================== CORE CRUD OPERATIONS ====================

  /**
   * Save a new assessment or update existing
   * MUST persist all child entities (RiskFlags) atomically
   */
  save(assessment: ReadinessAssessment): Promise<void>;

  /**
   * Find assessment by aggregate ID
   */
  findById(id: string): Promise<ReadinessAssessment | null>;

  /**
   * Find assessment by estate ID (1:1 Relationship)
   */
  findByEstateId(estateId: string): Promise<ReadinessAssessment | null>;

  /**
   * Check if assessment exists for estate
   */
  existsByEstateId(estateId: string): Promise<boolean>;

  /**
   * Delete assessment (Soft delete recommended)
   */
  delete(id: string): Promise<void>;

  // ==================== QUERY OPERATIONS ====================

  /**
   * Find all assessments with a specific status
   */
  findByStatus(status: ReadinessStatus): Promise<ReadinessAssessment[]>;

  /**
   * Find all assessments with critical blocking risks
   */
  findWithCriticalRisks(): Promise<ReadinessAssessment[]>;

  /**
   * Find assessments with score in range
   */
  findByScoreRange(minScore: number, maxScore: number): Promise<ReadinessAssessment[]>;

  /**
   * Find stale assessments (not updated in X hours)
   * Use case: Triggering background recalculation jobs
   */
  findStaleAssessments(staleHours: number): Promise<ReadinessAssessment[]>;

  /**
   * Find assessments ready to complete/file
   */
  findReadyToComplete(): Promise<ReadinessAssessment[]>;

  /**
   * Find assessments containing a specific risk category
   */
  findByRiskCategory(category: RiskCategory): Promise<ReadinessAssessment[]>;

  // ==================== PAGINATION SUPPORT ====================

  findAllPaginated(options: RepositoryQueryOptions): Promise<PaginatedResult<ReadinessAssessment>>;

  findByStatusPaginated(
    status: ReadinessStatus,
    options: RepositoryQueryOptions,
  ): Promise<PaginatedResult<ReadinessAssessment>>;

  // ==================== STATISTICS ====================

  count(): Promise<number>;
  countByStatus(status: ReadinessStatus): Promise<number>;
  getAverageScore(): Promise<number>;

  /**
   * Analytics: Get most common risk categories across the system
   */
  getMostCommonRisks(limit: number): Promise<Array<{ category: RiskCategory; count: number }>>;

  // ==================== BATCH OPERATIONS ====================

  /**
   * Save multiple assessments (bulk recalculation)
   */
  saveAll(assessments: ReadinessAssessment[]): Promise<void>;

  findByEstateIds(estateIds: string[]): Promise<ReadinessAssessment[]>;

  // ==================== RISK FLAG QUERIES ====================

  /**
   * Find assessments affected by a specific source event
   * e.g. "Find all assessments that have risks generated by Family Member X"
   */
  findByRiskSource(sourceType: string, sourceEntityId: string): Promise<ReadinessAssessment[]>;

  countUnresolvedRisks(): Promise<number>;
}
