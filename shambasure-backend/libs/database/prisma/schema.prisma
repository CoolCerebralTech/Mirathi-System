// Shamba Sure - Production-Ready
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -----------------------------------------------------------------------------
// ENUMS
// -----------------------------------------------------------------------------

enum UserRole {
  USER
  ADMIN
  VERIFIER
  AUDITOR
}

enum RelationshipType {
  SPOUSE
  CHILD
  PARENT
  SIBLING
  OTHER
}

enum WillStatus {
  DRAFT
  ACTIVE
  REVOKED
  EXECUTED
}

enum AssetType {
  LAND_PARCEL
  BANK_ACCOUNT
  VEHICLE
  PROPERTY
  OTHER
}

enum DocumentStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
}

enum DocumentCategory {
  LAND_OWNERSHIP       // Title deeds, purchase agreements, land registry extracts
  IDENTITY_PROOF       // National ID, birth certificate, death certificate
  SUCCESSION_DOCUMENT  // Wills, grant of probate, letters of administration
  FINANCIAL_PROOF      // Bank statements, lease documents
  OTHER                // Affidavits, court orders, witness statements
}

enum NotificationChannel {
  EMAIL
  SMS
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

// ============================================================================
// ACCOUNTS SERVICE MODELS
// Owner: accounts-service
// ============================================================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String   // Argon2id hashed password
  firstName String
  lastName  String
  role      UserRole @default(USER)
  isActive     Boolean  @default(true)
  lastLoginAt  DateTime?
  loginAttempts Int     @default(0)
  lockedUntil  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  // --- Relationships Owned by this Service ---
  profile                UserProfile?
  passwordResetTokens    PasswordResetToken[]
  refreshTokens          RefreshToken[]
  roleChanges            RoleChange[]
  emailVerificationToken EmailVerificationToken?
  phoneVerificationTokens PhoneVerificationToken[]
  emailChangeTokens      EmailChangeToken[]
  loginSessions          LoginSession[]
  passwordHistory        PasswordHistory[]

  // --- Back-relations from other services ---
  createdFamilies     Family[]
  familyMemberships   FamilyMember[]
  willsAsTestator     Will[]
  assetsOwned         Asset[]
  beneficiaryOf       BeneficiaryAssignment[]
  documentsUploaded   Document[]
  notifications       Notification[]
  auditLogsAsActor    AuditLog[]

  @@index([email, isActive])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("users")
}


model UserProfile {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  bio           String?
  phoneNumber   String?  @db.VarChar(20)
  phoneVerified Boolean  @default(false)
  emailVerified Boolean  @default(false)
  marketingOptIn Boolean @default(false)
  address       Json?    // {street, city, county, postalCode}
  nextOfKin     Json?    // {name, relationship, phone, email}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([phoneNumber])
  @@map("user_profiles")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId, used])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model RefreshToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique
  expiresAt DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId  String?
  ipAddress String?  @db.VarChar(45) // IPv6 support
  userAgent String?  @db.Text
  createdAt DateTime @default(now())
  revokedAt DateTime?
  lastUsedAt DateTime?

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model RoleChange {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  oldRole   UserRole
  newRole   UserRole
  changedBy String?
  reason    String?  @db.Text
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("role_changes")
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique
  expiresAt DateTime
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([expiresAt])
  @@map("email_verification_tokens")
}
model PhoneVerificationToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique  // Hashed OTP (6-digit code)
  expiresAt DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  used      Boolean  @default(false)
  attempts  Int      @default(0) // Track verification attempts
  createdAt DateTime @default(now())

  @@index([userId, used])
  @@index([expiresAt])
  @@map("phone_verification_tokens")
}

model EmailChangeToken {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  newEmail     String   // The new email user wants to change to
  tokenHash    String   @unique
  expiresAt    DateTime
  used         Boolean  @default(false)
  createdAt    DateTime @default(now())

  @@index([userId, used])
  @@index([expiresAt])
  @@map("email_change_tokens")
}

model LoginSession {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash     String    @unique 
  ipAddress     String?   @db.VarChar(45) // IPv6 support
  userAgent     String?   @db.Text
  deviceId      String?   // Unique device identifier
  lastActivity  DateTime  @default(now())
  expiresAt     DateTime
  revokedAt     DateTime? // For manual session termination
  createdAt     DateTime  @default(now())

  @@index([userId, expiresAt])
  @@index([deviceId])
  @@map("login_sessions")
}

model PasswordHistory {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  passwordHash String   // Store Argon2id hash of old password
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
  @@map("password_history")
}
// ============================================================================
// SUCCESSION SERVICE MODELS (Unchanged for now)
// Owner: succession-service
// ============================================================================

model Family {
  id        String   @id @default(uuid())
  name      String
  creatorId String
  creator   User     @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  members   FamilyMember[]

  @@index([creatorId])
}

model FamilyMember {
  userId   String
  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  familyId String
  family   Family           @relation(fields: [familyId], references: [id], onDelete: Cascade)
  role     RelationshipType

  @@id([userId, familyId])
}

model Will {
  id                     String                  @id @default(uuid())
  title                  String
  status                 WillStatus              @default(DRAFT)
  testatorId             String
  testator               User                    @relation(fields: [testatorId], references: [id], onDelete: Cascade)
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  beneficiaryAssignments BeneficiaryAssignment[]

  @@index([testatorId])
  Document Document[]
}

model Asset {
  id                     String                  @id @default(uuid())
  name                   String
  description            String?
  type                   AssetType
  ownerId                String
  owner                  User                    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  beneficiaryAssignments BeneficiaryAssignment[]

  @@index([ownerId])
  Document Document[]
}

model BeneficiaryAssignment {
  id            String   @id @default(uuid())
  willId        String
  will          Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  assetId       String
  asset         Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  beneficiaryId String
  beneficiary   User     @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)
  sharePercent  Decimal?
  createdAt     DateTime @default(now())

  @@unique([willId, assetId, beneficiaryId])
  @@index([beneficiaryId])
}

// ============================================================================
// DOCUMENTS SERVICE MODELS
// Owner: documents-service
// ============================================================================

model Document {
  id          String           @id @default(uuid())
  filename    String
  storagePath String           // Local path or cloud URL
  mimeType    String           @db.VarChar(100)
  sizeBytes   Int
  category    DocumentCategory
  status      DocumentStatus   @default(PENDING_VERIFICATION)

  // --- Ownership & Upload Info ---
  uploaderId  String
  uploader    User             @relation(fields: [uploaderId], references: [id], onDelete: Cascade)

  // --- Verification Tracking ---
  verifiedBy     String?       // User ID of verifier (ADMIN or VERIFIER role)
  verifiedAt     DateTime?
  rejectionReason String?      @db.Text

  // --- Cross-Service Links (Direct Foreign Keys) ---
  // A document can be linked to EITHER an Asset OR a Will (or neither for identity docs)
  assetId     String?
  asset       Asset?           @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  willId      String?
  will        Will?            @relation(fields: [willId], references: [id], onDelete: Cascade)

  // --- Metadata (Optional - for future AI/OCR extraction) ---
  metadata    Json?            // Store extracted data like parcel numbers, ID numbers, etc.

  // --- Timestamps ---
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  deletedAt   DateTime?        // Soft delete support

  // --- Relations ---
  versions    DocumentVersion[]

  // --- Indexes for Performance ---
  @@index([uploaderId])
  @@index([status])
  @@index([category])
  @@index([assetId])
  @@index([willId])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("documents")
}

model DocumentVersion {
  id            String   @id @default(uuid())
  versionNumber Int
  storagePath   String
  changeNote    String?  @db.Text
  sizeBytes     Int      // Track size per version
  mimeType      String   @db.VarChar(100)
  
  documentId    String
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  uploadedBy    String   // User who uploaded this version
  createdAt     DateTime @default(now())

  @@unique([documentId, versionNumber])
  @@index([documentId])
  @@index([createdAt])
  @@map("document_versions")
}

// ============================================================================
// NOTIFICATIONS SERVICE MODELS (Unchanged for now)
// Owner: notifications-service
// ============================================================================

model NotificationTemplate {
  id      String              @id @default(uuid())
  name    String              @unique
  channel NotificationChannel
  subject String?
  body    String

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  notifications Notification[]
}

model Notification {
  id          String             @id @default(uuid())
  channel     NotificationChannel
  status      NotificationStatus @default(PENDING)
  sentAt      DateTime?
  failReason  String?
  templateId  String
  template    NotificationTemplate @relation(fields: [templateId], references: [id])
  recipientId String?
  recipient   User?              @relation(fields: [recipientId], references: [id], onDelete: SetNull)
  createdAt   DateTime           @default(now())

  @@index([recipientId, status])
}

// ============================================================================
// AUDITING SERVICE MODEL (Unchanged for now)
// Owner: auditing-service
// ============================================================================

model AuditLog {
  id        String   @id @default(uuid())
  timestamp DateTime @default(now())
  actorId   String?
  actor     User?    @relation(fields: [actorId], references: [id], onDelete: SetNull)
  action    String
  payload   Json

  @@index([actorId])
  @@index([action, timestamp])
}
