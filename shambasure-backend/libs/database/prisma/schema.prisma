datasource db {
  provider = "postgresql"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}
// -----------------------------------------------------------------------------
// ENUMS
// -----------------------------------------------------------------------------
enum UserRole {
  USER
  ADMIN
  VERIFIER
  AUDITOR
}
enum Gender {
  MALE
  FEMALE
  OTHERS
}
enum RoadmapPhase {
  PRE_FILING           
  FILING_AND_GAZETTE   
  CONFIRMATION         
  DISTRIBUTION         
  CLOSED
}
enum TaskStatus {
  LOCKED
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}
enum ProbateApplicationType {
  GRANT_OF_PROBATE           // P&A 1
  LETTERS_OF_ADMINISTRATION  // P&A 80
  SUMMARY_ADMINISTRATION     // P&A 5
  LIMITED_GRANT              // Ad Litem / Collection
}
enum KenyanFormType {
  PA1_PETITION
  PA5_PETITION_SUMMARY
  PA80_PETITION_INTESTATE
  PA12_AFFIDAVIT_MEANS
  PA38_CONSENT
  PA57_GUARANTEE
  CHIEFS_LETTER_TEMPLATE
}
enum ConsentStatus {
  PENDING
  GRANTED
  DECLINED
  NOT_REQUIRED
}
enum SuccessionRegime {
  TESTATE              // Valid Will exists
  INTESTATE            // No Will
  PARTIALLY_INTESTATE  // Will exists but doesn't cover all assets
  CUSTOMARY            // Managed by elders (rare but valid)
}
enum SuccessionMarriageType {
  MONOGAMOUS
  POLYGAMOUS           // Triggers S.40 Logic
  COHABITATION         // Triggers S.3(5) & S.29 Logic (Likely Dispute)
  SINGLE
}
enum SuccessionReligion {
  STATUTORY            // Law of Succession Act (General)
  ISLAMIC              // Subject to Sharia (Kadhi's Court)
  HINDU                // Hindu Succession Act
  AFRICAN_CUSTOMARY    // Customary Law
  CHRISTIAN            // Often Statutory
}
enum RiskSeverity {
  CRITICAL             // Cannot file (e.g. No Death Cert)
  HIGH                 // Likely dispute
  MEDIUM               // Warning
  LOW                  // Info
}
enum RiskSource {
  FAMILY_SERVICE       // e.g. "Found a minor child with no guardian"
  ESTATE_SERVICE       // e.g. "Asset value requires higher court"
  WILL_SERVICE         // e.g. "Will witness is also a beneficiary"
  DOCUMENT_SERVICE     // e.g. "ID scan is blurry"
  EXTERNAL_REGISTRY    // e.g. "KRA PIN is inactive"
}
enum ReadinessStatus {
  IN_PROGRESS
  READY_TO_FILE
  BLOCKED
}
enum DocumentStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
}
enum DocumentCategory {
  LAND_OWNERSHIP       // Title deeds, purchase agreements, land registry extracts
  IDENTITY_PROOF       // National ID, birth certificate, death certificate
  SUCCESSION_DOCUMENT  // Wills, grant of probate, letters of administration
  FINANCIAL_PROOF      // Bank statements, lease documents
  OTHER                // Affidavits, court orders, witness statements
}
enum RetentionPolicy {
  SHORT_TERM  // 1 year
  MEDIUM_TERM // 7 years  
  LONG_TERM   // Permanent
  COMPLIANCE  // Based on regulation
}
enum RelationshipType {
  SPOUSE
  EX_SPOUSE          // For divorced/separated spouses
  CHILD
  ADOPTED_CHILD      // Legal distinction for inheritance
  STEPCHILD          // From current/previous marriage
  PARENT
  SIBLING
  HALF_SIBLING       // Same parent
  GRANDCHILD
  GRANDPARENT
  NIECE_NEPHEW
  AUNT_UNCLE
  COUSIN
  GUARDIAN           // Legal guardian (non-parent)
  OTHER
}
enum RelationshipGuardianshipType {
  TEMPORARY
  PERMANENT
  TESTAMENTARY
  CUSTOMARY
}
enum MarriageType {
  CIVIL
  CHRISTIAN
  CUSTOMARY
  ISLAMIC
  HINDU
  OTHER
}
enum MarriageEndReason {
  DEATH_OF_SPOUSE
  DIVORCE
  ANNULMENT
  CUSTOMARY_DISSOLUTION
  STILL_ACTIVE
}
enum MarriageStatus {
  SINGLE
  MARRIED
  DIVORCED
  WIDOWED
  SEPARATED
}
enum KenyanRelationshipCategory {
  SPOUSE
  CHILDREN
  PARENTS
  SIBLINGS
  EXTENDED_FAMILY
  NON_FAMILY
}
enum DependencyLevel {
  NONE
  PARTIAL
  FULL
}
enum KenyanLawSection {
  S26_DEPENDANT_PROVISION
  S29_DEPENDANTS
  S35_SPOUSAL_CHILDS_SHARE
  S40_POLY_GAMY
  S45_DEBT_PRIORITY
  S70_TESTAMENTARY_GUARDIAN
  S71_COURT_GUARDIAN
  S72_GUARDIAN_BOND
  S73_GUARDIAN_ACCOUNTS
  S83_EXECUTOR_DUTIES
}
enum GuardianReportStatus {
  PENDING
  DUE
  SUBMITTED
  APPROVED
  OVERDUE
  REJECTED
}
enum GuardianshipTerminationReason {
  WARD_REACHED_MAJORITY
  WARD_DECEASED
  GUARDIAN_DECEASED
  GUARDIAN_INCAPACITATED
  COURT_REMOVAL
  VOLUNTARY_RESIGNATION
  WARD_REGAINED_CAPACITY
  ADOPTION_FINALIZED
  CUSTOMARY_TRANSFER
}
enum GuardianType {
  TESTAMENTARY      // Appointed by Will (S.70 LSA) - stored here as fact
  COURT_APPOINTED   // Appointed by Children's Court
  CUSTOMARY         // Recognized by clan elders
  NATURAL_PARENT    // Default
}
enum InheritanceRights {
  FULL              // Full statutory rights
  PARTIAL           // Reduced rights (e.g., stepchild)
  CUSTOMARY         // Customary law applies
  NONE              // Explicitly excluded
  PENDING           // Awaiting court determination
}
enum GuardianAppointmentSource {
  FAMILY
  COURT
  WILL
  CUSTOMARY_LAW
}
enum ComplianceStatus {
  PENDING
  FILED
  OVERDUE
  REJECTED
}
enum GuardianshipStatus {
  ACTIVE
  SUSPENDED
  TERMINATED
  EXPIRED_WARD_MAJORITY
}
enum WillStatus {
  DRAFT              // Initial creation, editable
  PENDING_WITNESS    // Awaiting witness signatures
  WITNESSED          // Legally witnessed, not yet active
  ACTIVE             // Current valid will
  REVOKED            // Invalidated by user
  SUPERSEDED         // Replaced by newer will
  EXECUTED           // Testator deceased, distribution complete
  CONTESTED          // Under legal dispute
  PROBATE            // In court for grant of probate
}
enum WillType {
  STANDARD
  JOINT_WILL
  MUTUAL_WILL
  HOLOGRAPHIC
  INTERNATIONAL
  TESTAMENTARY_TRUST_WILL
}
enum RevocationMethod {
  NEW_WILL                // Superseded by new will
  CODICIL                 // Amendment
  DESTRUCTION             // Physical destruction
  COURT_ORDER             // Court-ordered revocation
  MARRIAGE                // Marriage revokes prior will (common law)
  DIVORCE                 // Divorce may affect will
  OTHER
}
enum WillStorageLocation {
  SAFE_DEPOSIT_BOX
  LAWYER_OFFICE
  HOME_SAFE
  DIGITAL_VAULT
  COURT_REGISTRY
  WITH_EXECUTOR
  OTHER
}
enum LegalCapacityStatus {
  ASSESSED_COMPETENT
  ASSESSED_INCOMPETENT
  PENDING_ASSESSMENT
  MEDICAL_CERTIFICATION
  COURT_DETERMINATION
  SELF_DECLARATION
}
enum WitnessType {
  REGISTERED_USER
  EXTERNAL_INDIVIDUAL
  PROFESSIONAL_WITNESS    // Lawyer, notary
  COURT_OFFICER
  NOTARY_PUBLIC
}
enum WitnessVerificationMethod {
  NATIONAL_ID
  PASSPORT
  DRIVERS_LICENSE
  BIRTH_CERTIFICATE
  ALIEN_CARD
  MILITARY_ID
  OTHER
}
enum WitnessEligibilityStatus {
  ELIGIBLE
  INELIGIBLE_MINOR
  INELIGIBLE_BENEFICIARY
  INELIGIBLE_SPOUSE
  INELIGIBLE_EXECUTOR
  INELIGIBLE_RELATIONSHIP
  INELIGIBLE_MENTAL_CAPACITY
  INELIGIBLE_CRIMINAL_RECORD
  PENDING_ELIGIBILITY_CHECK
}
enum WitnessStatus {
  PENDING                 // Awaiting signature
  SIGNED                  // Signature captured
  VERIFIED                // Identity verified
  REJECTED                // Declined to witness
}
enum SignatureType {
  DIGITAL_SIGNATURE
  WET_SIGNATURE
  E_SIGNATURE
  BIOMETRIC_SIGNATURE
  WITNESS_MARK
}
enum AssetType {
  LAND_PARCEL        // Title deeds, subdivision plots
  PROPERTY           // Houses, rentals, buildings
  FINANCIAL_ASSET    // Bank accounts, SACCO shares, investments
  DIGITAL_ASSET      // Crypto, NFTs, online portfolios, social media
  BUSINESS_INTEREST  // Company shares, partnerships, farm ventures
  VEHICLE            // Cars, motorcycles, tractors
  INTELLECTUAL_PROPERTY // Patents, copyrights, trademarks
  LIVESTOCK          // Cattle, goats, poultry
  PERSONAL_EFFECTS   // Jewelry, art, family heirlooms
  OTHER
}
enum AssetOwnershipType {
  SOLE               // Single owner
  JOINT_TENANCY      // Joint owners with right of survivorship
  TENANCY_IN_COMMON  // Shared ownership with separate shares
  COMMUNITY_PROPERTY // Marital property
}
enum AssetVerificationStatus {
  UNVERIFIED
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
  DISPUTED
}
enum AssetEncumbranceType {
  MORTGAGE
  CHARGE
  LIEN
  COURT_ORDER
  FAMILY_CLAIM
  OTHER
}
enum BequestType {
  SPECIFIC           // Specific asset to specific person
  RESIDUARY          // Remainder after specific bequests
  CONDITIONAL        // Only if condition met
  TRUST              // Held in trust until condition
  PERCENTAGE         // Percentage of total estate
}
enum BequestConditionType {
  AGE_REQUIREMENT    // "When beneficiary turns 25"
  SURVIVAL           // "If they survive me by 30 days"
  EDUCATION          // "Upon graduation"
  MARRIAGE           // "Upon marriage"
  ALTERNATE          // "If primary dies, give to alternate"
  NONE
}
enum BeneficiaryType {
  USER                    // Registered user
  FAMILY_MEMBER           // From family-service
  EXTERNAL                // Non-registered person
  CHARITY                 // Charitable organization
  ORGANIZATION            // Company, trust
}
enum BequestPriority {
  PRIMARY
  ALTERNATE
  CONTINGENT
}
enum DebtType {
  MORTGAGE
  PERSONAL_LOAN
  CREDIT_CARD
  BUSINESS_DEBT
  TAX_OBLIGATION
  FUNERAL_EXPENSE
  MEDICAL_BILL
  OTHER
}
enum DebtTier {
  FUNERAL_EXPENSES      // S. 45(a)
  TESTAMENTARY_EXPENSES // S. 45(a)
  SECURED_DEBTS         // S. 45(b)
  TAXES_RATES_WAGES     // S. 45(c)
  UNSECURED_GENERAL     // S. 45(d)
}
enum DebtPriority {
  HIGHEST                 // Funeral expenses, taxes (S. 45(a) LSA)
  HIGH                    // Secured debts (S. 45(b) LSA)
  MEDIUM                  // Unsecured priority debts
  LOW                     // Unsecured non-priority debts
}
enum DebtStatus {
  OUTSTANDING
  PARTIALLY_PAID
  SETTLED
  WRITTEN_OFF
  DISPUTED
  STATUTE_BARRED          // Time-barred under Limitation Act
}
enum ExecutorAppointmentType {
  TESTAMENTARY            // Appointed by will
  COURT_APPOINTED         // Appointed by court
  ADMINISTRATOR           // Letters of administration
  SPECIAL_EXECUTOR        // For specific purposes
}
enum KenyanCounty {
  BARINGO
  BOMET
  BUNGOMA
  BUSIA
  ELGEYO_MARAKWET
  EMBU
  GARISSA
  HOMA_BAY
  ISIOLO
  KAJIADO
  KAKAMEGA
  KERICHO
  KIAMBU
  KILIFI
  KIRINYAGA
  KISII
  KISUMU
  KITUI
  KWALE
  LAIKIPIA
  LAMU
  MACHAKOS
  MAKUENI
  MANDERA
  MARSABIT
  MERU
  MIGORI
  MOMBASA
  MURANGA
  NAIROBI
  NAKURU
  NANDI
  NAROK
  NYAMIRA
  NYANDARUA
  NYERI
  SAMBURU
  SIAYA
  TAITA_TAVETA
  TANA_RIVER
  THARAKA_NITHI
  TRANS_NZOIA
  TURKANA
  UASIN_GISHU
  VIHIGA
  WAJIR
  WEST_POKOT
}
enum NotificationChannel {
  EMAIL
  SMS
}
enum NotificationStatus {
  PENDING
  SENT
  FAILED
}
// ============================================================================
// ACCOUNTS SERVICE MODELS
// Owner: accounts-service
// ============================================================================

model User {
  id              String   @id @default(uuid()) @db.Uuid()
  email           String   @unique(map: "users_email_unique") @db.VarChar(255)
  password        String   @db.VarChar(255) // Argon2id hashed password
  firstName       String   @db.VarChar(100)
  lastName        String   @db.VarChar(100)
  role            UserRole @default(USER)
  isActive        Boolean  @default(true)
  lastLoginAt     DateTime?
  loginAttempts   Int      @default(0)
  lockedUntil     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  // --- Relationships Owned by this Service ---
  profile                UserProfile?
  passwordResetTokens    PasswordResetToken[]
  refreshTokens          RefreshToken[]
  roleChanges            RoleChange[]
  emailVerificationToken EmailVerificationToken?
  phoneVerificationTokens PhoneVerificationToken[]
  emailChangeTokens      EmailChangeToken[]
  loginSessions          LoginSession[]
  passwordHistory        PasswordHistory[]

  // --- Back-relations from other services ---
  documentsUploaded         Document[]              @relation("DocumentUploader")
  Document Document[] @relation("UserIdentityDocuments")
  DocumentVerificationAttempt DocumentVerificationAttempt[]
  notifications       Notification[]
  auditLogsAsActor          AuditLog[]              @relation("AuditActor")  
  // Back-relations from Family-Service
  createdFamilies     Family[]       @relation("FamilyCreator")
  familyMemberships   FamilyMember[] @relation("FamilyMemberUser")
  // Back-relations from Estate-Service
  
  willsAuthored               Will[] @relation("TestatorWills")
  assetsOwned         Asset[]        @relation("AssetOwner")
  assetCoOwnerships   AssetCoOwner[] @relation("CoOwnerUser")
  willExecutorRoles   WillExecutor[] @relation("ExecutorUser")
  witnessRoles        WillWitness[]  @relation("WitnessUser")
  beneficiaryOf       BeneficiaryAssignment[] @relation("AssignmentBeneficiaryUser")
  @@index([email, isActive], map: "users_email_isActive_idx")
  @@index([createdAt], map: "users_createdAt_idx")
  @@index([deletedAt], map: "users_deletedAt_idx")
  @@map("users")
}
model UserProfile {
  id            String   @id @default(uuid()) @db.Uuid()
  userId        String   @unique(map: "user_profiles_userId_unique") @db.Uuid()
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  bio            String?   @db.Text
  phoneNumber    String?   @db.VarChar(20)
  phoneVerified  Boolean   @default(false)
  emailVerified  Boolean   @default(false)
  marketingOptIn Boolean   @default(false)
  address        Json?     // {street, city, county, postalCode}
  nextOfKin      Json?     // {name, relationship, phone, email}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([phoneNumber], map: "user_profiles_phoneNumber_idx")
  @@map("user_profiles")
}
model PasswordResetToken {
  id        String   @id @default(uuid()) @db.Uuid()
  tokenHash String   @unique(map: "password_reset_tokens_tokenHash_unique") @db.VarChar(255)
  expiresAt DateTime
  used      Boolean  @default(false)
  userId    String   @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  createdAt DateTime @default(now())

  @@index([userId, used], map: "password_reset_tokens_userId_used_idx")
  @@index([expiresAt], map: "password_reset_tokens_expiresAt_idx")
  @@map("password_reset_tokens")
}
model RefreshToken {
  id        String   @id @default(uuid()) @db.Uuid()
  tokenHash String   @unique(map: "refresh_tokens_tokenHash_unique") @db.VarChar(255)
  expiresAt DateTime
  userId    String   @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  deviceId  String?  @db.VarChar(255)
  ipAddress String?  @db.VarChar(45) // IPv6 support
  userAgent String?  @db.Text
  createdAt DateTime @default(now())
  revokedAt DateTime?
  lastUsedAt DateTime?

  @@index([userId], map: "refresh_tokens_userId_idx")
  @@index([expiresAt], map: "refresh_tokens_expiresAt_idx")
  @@map("refresh_tokens")
}
model RoleChange {
  id        String   @id @default(uuid()) @db.Uuid()
  userId    String   @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  oldRole   UserRole
  newRole   UserRole
  changedBy String?  @db.Uuid()
  reason    String?  @db.Text
  
  createdAt DateTime @default(now())

  @@index([userId], map: "role_changes_userId_idx")
  @@index([createdAt], map: "role_changes_createdAt_idx")
  @@map("role_changes")
}
model EmailVerificationToken {
  id        String   @id @default(uuid()) @db.Uuid()
  tokenHash String   @unique(map: "email_verification_tokens_tokenHash_unique") @db.VarChar(255)
  expiresAt DateTime
  userId    String   @unique(map: "email_verification_tokens_userId_unique") @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  createdAt DateTime @default(now())

  @@index([expiresAt], map: "email_verification_tokens_expiresAt_idx")
  @@map("email_verification_tokens")
}
model PhoneVerificationToken {
  id        String   @id @default(uuid()) @db.Uuid()
  tokenHash String   @unique(map: "phone_verification_tokens_tokenHash_unique") @db.VarChar(255)
  expiresAt DateTime
  userId    String   @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  used      Boolean  @default(false)
  attempts  Int      @default(0) // Track verification attempts
  createdAt DateTime @default(now())

  @@index([userId, used], map: "phone_verification_tokens_userId_used_idx")
  @@index([expiresAt], map: "phone_verification_tokens_expiresAt_idx")
  @@map("phone_verification_tokens")
}
model EmailChangeToken {
  id        String   @id @default(uuid()) @db.Uuid()
  userId    String   @db.Uuid()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  newEmail     String   @db.VarChar(255)
  tokenHash    String   @unique(map: "email_change_tokens_tokenHash_unique") @db.VarChar(255)
  expiresAt    DateTime
  used         Boolean  @default(false)
  createdAt    DateTime @default(now())

  @@index([userId, used], map: "email_change_tokens_userId_used_idx")
  @@index([expiresAt], map: "email_change_tokens_expiresAt_idx")
  @@map("email_change_tokens")
}
model LoginSession {
  id           String    @id @default(uuid()) @db.Uuid()
  userId       String    @db.Uuid()
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  tokenHash    String    @unique(map: "login_sessions_tokenHash_unique") @db.VarChar(255)
  ipAddress    String?   @db.VarChar(45) // IPv6 support
  userAgent    String?   @db.Text
  deviceId     String?   @db.VarChar(255)
  lastActivity DateTime  @default(now())
  expiresAt    DateTime
  revokedAt    DateTime? // For manual session termination
  createdAt    DateTime  @default(now())

  @@index([userId, expiresAt], map: "login_sessions_userId_expiresAt_idx")
  @@index([deviceId], map: "login_sessions_deviceId_idx")
  @@map("login_sessions")
}
model PasswordHistory {
  id           String   @id @default(uuid()) @db.Uuid()
  userId       String   @db.Uuid()
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  passwordHash String   @db.VarChar(255) // Store Argon2id hash of old password
  createdAt    DateTime @default(now())

  @@index([userId, createdAt], map: "password_history_userId_createdAt_idx")
  @@map("password_history")
}
// ============================================================================
// DOCUMENTS SERVICE MODELS
// Owner: documents-service
// ============================================================================
model Document {
  id          String           @id @default(uuid()) @db.Uuid()
  version     Int
  filename    String           @db.VarChar(500)
  storagePath String           @db.Text
  mimeType    String           @db.VarChar(100)
  sizeBytes   Int
  category    DocumentCategory
  status      DocumentStatus   @default(PENDING_VERIFICATION)

 // --- Ownership & Upload Info ---
  uploaderId        String   @db.Uuid()
  uploader          User     @relation("DocumentUploader", fields: [uploaderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  identityForUserId String?  @db.Uuid()
  identityForUser   User?    @relation("UserIdentityDocuments", fields: [identityForUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // --- Verification Tracking ---
  verifiedBy        String?   @db.Uuid()
  verifiedAt        DateTime?
  rejectionReason   String?   @db.Text    

  // Retention & Expiry
  expiresAt   DateTime? // Auto-delete after this date
  retentionPolicy String? @db.VarChar(50)// COMPLIANCE, LEGAL, etc.

  // Access Control List
  allowedViewers Json? // User IDs who can view this document

  // Security & Access
  isPublic    Boolean   @default(false)
  encrypted   Boolean   @default(false)
  // --- Cross-Service Links ---
  assetId String? @db.Uuid()
  asset   Asset?  @relation(fields: [assetId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  willId  String? @db.Uuid()
  will    Will?   @relation(fields: [willId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  // --- Metadata ---
  metadata    Json?
  documentNumber    String? @db.VarChar(100)
  issueDate         DateTime?
  expiryDate        DateTime?
  issuingAuthority  String? @db.VarChar(200)

  // --- Timestamps ---
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  deletedAt   DateTime?        // Soft delete support


  // Storage optimization
  storageProvider String @default("local") @db.VarChar(50)
  checksum        String? @db.VarChar(64)
  
  // Performance fields
  isIndexed      Boolean @default(false) // For search indexing
  indexedAt      DateTime?

  // --- Relations ---
  versions    DocumentVersion[]
  verificationAttempts        DocumentVerificationAttempt[]
  willWitnesses WillWitness[] @relation("WitnessIdentityDocuments") 

  @@index([uploaderId, status, createdAt], map: "documents_uploader_status_createdAt_idx")
  @@index([category, status, createdAt], map: "documents_category_status_createdAt_idx")
  @@index([assetId, willId, identityForUserId], map: "documents_cross_service_idx")
  @@index([createdAt, deletedAt], map: "documents_createdAt_deletedAt_idx")
  @@index([uploaderId], map: "documents_uploaderId_idx")
  @@index([createdAt], map: "documents_createdAt_idx")
  @@index([deletedAt], map: "documents_deletedAt_idx")
  @@index([isPublic], map: "documents_isPublic_idx")
  @@index([encrypted], map: "documents_encrypted_idx")
  @@index([documentNumber], map: "documents_documentNumber_idx")
  @@index([expiryDate], map: "documents_expiryDate_idx")
  @@map("documents")
}
model DocumentVersion {
  id            String   @id @default(uuid()) @db.Uuid()
  versionNumber Int
  storagePath   String   @db.Text
  changeNote    String?  @db.Text
  sizeBytes     Int
  mimeType      String   @db.VarChar(100)
  checksum      String?  @db.VarChar(64)
  
  documentId    String   @db.Uuid()
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  uploadedBy    String   @db.Uuid()
  createdAt     DateTime @default(now())

  @@unique([documentId, versionNumber], map: "document_versions_document_version_unique")
  @@index([documentId], map: "document_versions_documentId_idx")
  @@index([createdAt], map: "document_versions_createdAt_idx")
  @@map("document_versions")
}
model DocumentVerificationAttempt {
  id         String           @id @default(uuid()) @db.Uuid()
  documentId String           @db.Uuid()
  document   Document         @relation(fields: [documentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  verifierId String          @db.Uuid()
  verifier   User            @relation(fields: [verifierId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  status     DocumentStatus
  reason     String?         @db.Text
  metadata   Json?
  createdAt  DateTime        @default(now())

  @@index([documentId], map: "document_verification_attempts_documentId_idx")
  @@index([verifierId], map: "document_verification_attempts_verifierId_idx")
  @@index([createdAt], map: "document_verification_attempts_createdAt_idx")
  @@map("document_verification_attempts")
}
// ============================================================================
// FAMILY-SERVICE SCHEMA
// Purpose: Manages Identity, Kinship, and Legal Authority (Guardianship)
// Context: Kenyan Law (Marriage Act, Children Act, S.40 Succession Act)
// ============================================================================
// ============================================================================
// AGGREGATE ROOT 1: FAMILY
// Manages: Kinship, S.40 Structure, Identity
// ============================================================================
model Family {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- Core Identity ---
  name                String   @db.VarChar(200) // e.g., "The Otieno Family"
  description         String?  @db.Text
  creatorId           String   @db.Uuid() // Reference to Auth User

  // --- Kenyan Cultural Identity ---
  clanName            String?  @db.VarChar(100)
  subClan             String?  @db.VarChar(100)
  ancestralHome       String?  @db.VarChar(200)
  familyTotem         String?  @db.VarChar(100)
  homeCounty          KenyanCounty?

  // --- Aggregate Stats (Denormalized) ---
  memberCount         Int      @default(0)
  isPolygamous        Boolean  @default(false)
  
  // --- Concurrency ---
  version             Int      @default(1)

  // --- Relations (Entities) ---
  
  users                   User[] @relation("FamilyCreator")
  members                 FamilyMember[]
  marriages               Marriage[]
  relationships           FamilyRelationship[]
  polygamousHouses        PolygamousHouse[]
  cohabitationRecords     CohabitationRecord[]
  adoptionOrders          AdoptionOrder[]
  nextOfKinDesignations   NextOfKinDesignation[]
  events                  FamilyLegalEvent[]

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  deletedAt           DateTime?

  @@map("families")
}
model FamilyMember {
  id             String   @id @default(uuid()) @db.Uuid()
  
  // --- Links ---
  familyId       String   @db.Uuid()
  family         Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)
  userId         String?  @unique @db.Uuid() // Link to Auth User if they exist

  // --- Personal Identity (Entities/family-member.entity.ts) ---
  firstName      String   @db.VarChar(100)
  middleName     String?  @db.VarChar(100)
  lastName       String   @db.VarChar(100)
  maidenName     String?  @db.VarChar(100)
  
  // --- Kenyan Official IDs ---
  nationalId     String?  @unique @db.VarChar(20)
  kraPin         String?  @unique @db.VarChar(20)
  nationalIdVerified Boolean @default(false)

  // --- Demographics ---
  dateOfBirth    DateTime?
  gender         Gender?
  placeOfBirth   String?  @db.VarChar(100)
  religion       String?  @db.VarChar(50) // Relevant for Islamic law

  // --- Life Status (Facts) ---
  isAlive        Boolean  @default(true)
  dateOfDeath    DateTime?
  deathCertNo    String?  @db.VarChar(50)
  isMissing      Boolean  @default(false)

  // --- Medical Facts (Not Entitlement) ---
  disabilityStatus String? @db.VarChar(50) // "NONE", "PHYSICAL", "MENTAL"
  // Note: Dependency Claims are now in Estate Service

  // --- S.40 Polygamy Link ---
  polygamousHouseId String? @db.Uuid()
  polygamousHouse   PolygamousHouse? @relation("HouseChildren", fields: [polygamousHouseId], references: [id])

  // --- Relations ---
  
  users                 User[] @relation("FamilyMemberUser")
  relationshipsFrom     FamilyRelationship[] @relation("RelFrom")
  relationshipsTo       FamilyRelationship[] @relation("RelTo")
  marriages1            Marriage[]           @relation("Spouse1")
  marriages2            Marriage[]           @relation("Spouse2")
  
  // Guardianship Roles
  guardianshipsAsWard   Guardianship[]       @relation("Ward")
  assignmentsAsGuardian GuardianAssignment[] @relation("AppointedGuardian")
  assets                Asset[] @relation("FamilyMemberLifeInterest")
  beneficiaryAssignments BeneficiaryAssignment[] @relation("BeneficiaryFamilyMember")
  disinheritanceRecords DisinheritanceRecord[] @relation("DisinheritedMember")
  giftInterVivos GiftInterVivos[] @relation("GiftRecipient")
  dependencyClaimsAgainstMe LegalDependant[] @relation("DeceasedDependant")
  myDependencyClaims  LegalDependant[] @relation("DependantOf")
  CustodialParent  LegalDependant[] @relation("CustodialParent")
  // Customary Roles
  houseHeadOf           PolygamousHouse?     @relation("HouseHead")
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("family_members")
  
}
model PolygamousHouse {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- Links ---
  familyId            String   @db.Uuid()
  family              Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // --- House Identity (S.40 LSA) ---
  houseName           String   @db.VarChar(100) // e.g. "House of Wanjiku"
  houseOrder          Int      // 1st House, 2nd House
  
  // --- The Head (Wife or Eldest Son) ---
  houseHeadId         String?  @unique @db.Uuid()
  houseHead           FamilyMember? @relation("HouseHead", fields: [houseHeadId], references: [id])

  // --- Fact of Establishment ---
  establishedDate     DateTime
  courtRecognized     Boolean  @default(false) // If verified by court
  
  // --- Relations ---
  marriages           Marriage[] // The marriage(s) creating this house
  children            FamilyMember[] @relation("HouseChildren")

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@unique([familyId, houseOrder])
  @@map("polygamous_houses")
}
model Marriage {
  id                  String   @id @default(uuid()) @db.Uuid()
  familyId            String   @db.Uuid()
  family              Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // --- Spouses ---
  spouse1Id           String   @db.Uuid()
  spouse1             FamilyMember @relation("Spouse1", fields: [spouse1Id], references: [id])
  spouse2Id           String   @db.Uuid()
  spouse2             FamilyMember @relation("Spouse2", fields: [spouse2Id], references: [id])

  // --- Type & Validity ---
  marriageType        MarriageType
  registrationNumber  String?  @unique @db.VarChar(100)
  startDate           DateTime
  endDate             DateTime?
  endReason           MarriageEndReason @default(STILL_ACTIVE)

  // --- Polygamy Context ---
  isPolygamous        Boolean  @default(false)
  polygamousHouseId   String?  @db.Uuid()
  polygamousHouse     PolygamousHouse? @relation(fields: [polygamousHouseId], references: [id])

  // --- Customary Specifics ---
  bridePricePaid      Boolean  @default(false)
  customaryDetails    Json?    // Elders present, location

  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("marriages")
}
model FamilyRelationship {
  id                  String   @id @default(uuid()) @db.Uuid()
  familyId            String   @db.Uuid()
  family              Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  fromMemberId        String   @db.Uuid()
  fromMember          FamilyMember @relation("RelFrom", fields: [fromMemberId], references: [id])
  toMemberId          String   @db.Uuid()
  toMember            FamilyMember @relation("RelTo", fields: [toMemberId], references: [id])

  type                RelationshipType
  isBiological        Boolean  @default(true)
  isVerified          Boolean  @default(false) // DNA or Document proof
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@unique([fromMemberId, toMemberId, type])
  @@map("family_relationships")
}
model CohabitationRecord {
  id              String   @id @default(uuid()) @db.Uuid()
  familyId        String   @db.Uuid()
  family          Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  // --- Partners ---
  // Using generic IDs to avoid complex relation cycles, or simplified lookups
  partner1Id      String   @db.Uuid()
  partner2Id      String   @db.Uuid()
  
  // --- Facts (Used by Estate Service to prove S.29(5)) ---
  startDate       DateTime
  endDate         DateTime?
  isAcknowledged  Boolean  @default(false) // By community
  hasChildren     Boolean  @default(false)
  affidavitFileId String?  @db.Uuid()      // Proof document

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("cohabitation_records")
}
model AdoptionOrder {
  id              String   @id @default(uuid()) @db.Uuid()
  familyId        String   @db.Uuid()
  family          Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  adopteeId       String   @db.Uuid()
  adopterId       String   @db.Uuid()
  
  courtOrderNo    String?  @unique
  adoptionDate    DateTime
  type            String   // STATUTORY, CUSTOMARY

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("adoption_orders")
}
model NextOfKinDesignation {
  id              String   @id @default(uuid()) @db.Uuid()
  familyId        String   @db.Uuid()
  family          Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  designatorId    String   @db.Uuid() // Who is picking
  nomineeId       String   @db.Uuid() // Who is picked
  
  priority        Int      @default(1)
  relationType    String?  // Description
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([designatorId, priority])
  @@map("next_of_kin_designations")
}
// ============================================================================
// AGGREGATE ROOT 2: GUARDIANSHIP
// Manages: Legal Authority, Care Responsibility (Children Act)
// ============================================================================
model Guardianship {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- The Ward (Identity Reference) ---
  wardId              String   @db.Uuid()
  ward                FamilyMember @relation("Ward", fields: [wardId], references: [id])
  
  // --- Aggregate State ---
  status              GuardianshipStatus @default(ACTIVE)
  establishedDate     DateTime
  validUntil          DateTime? // Usually 18th birthday
  
  // --- Legal Basis ---
  basis               GuardianType
  courtOrderNumber    String?   @db.VarChar(100)
  courtStation        String?   @db.VarChar(100)
  
  // --- Entities ---
  assignments         GuardianAssignment[]
  complianceChecks    ComplianceCheck[]

  // --- Audit ---
  version             Int      @default(1)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("guardianships")
}

model GuardianAssignment {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- Aggregate Root Link ---
  guardianshipId      String   @db.Uuid()
  guardianship        Guardianship @relation(fields: [guardianshipId], references: [id], onDelete: Cascade)

  // --- The Guardian (Identity Reference) ---
  guardianId          String   @db.Uuid()
  guardian            FamilyMember @relation("AppointedGuardian", fields: [guardianId], references: [id])

  // --- Role Details ---
  isPrimary           Boolean  @default(true)
  appointmentDate     DateTime
  
  // --- Powers (Children Act) ---
  canManageProperty   Boolean  @default(false) // If false, Estate Service appoints Trustee
  canConsentMedical   Boolean  @default(true)

  // --- Bonding (S.72 LSA requirement for guardians of property) ---
  bondRequired        Boolean  @default(false)
  bondReference       String?  // Document ID

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("guardian_assignments")
}
model ComplianceCheck {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- Aggregate Root Link ---
  guardianshipId      String   @db.Uuid()
  guardianship        Guardianship @relation(fields: [guardianshipId], references: [id], onDelete: Cascade)

  // --- Filing Details ---
  year                Int
  filingDate          DateTime?
  status              ComplianceStatus @default(PENDING)
  
  // --- Outcome ---
  notes               String?  @db.Text
  reportDocumentId    String?  @db.Uuid() // Link to PDF report
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@unique([guardianshipId, year])
  @@map("compliance_checks")
}
// ============================================================================
// SHARED / UTILS
// ============================================================================
model FamilyLegalEvent {
  id             String   @id @default(uuid()) @db.Uuid()
  familyId       String   @db.Uuid()
  family         Family   @relation(fields: [familyId], references: [id], onDelete: Cascade)

  eventType      String   @db.VarChar(100)
  description    String   @db.Text
  metadata       Json?
  
  recordedAt     DateTime @default(now())
  recordedBy     String?  @db.Uuid()

  @@map("family_legal_events")
}
// ============================================================================
// ESTATE-SERVICE MODELS
// Purpose: Manages the Inventory (Estate) and Instructions (Will).
// Strict Boundaries: No Court Processes, No Grants, No Transmissions.
// ============================================================================

// =============================================================================
// AGGREGATE ROOT 1: ESTATE
// Purpose: The Inventory & Net Worth.
// Invariants: Assets >= Debts (Solvency), Total Ownership = 100%
// =============================================================================
model Estate {
  id                     String   @id @default(uuid()) @db.Uuid()
  
  // --- Deceased Identity (Link to Family Service) ---
  deceasedId             String   @unique(map: "estates_deceasedId_unique") @db.Uuid()
  // Denormalized for search performance
  deceasedFullName       String   @db.VarChar(200)
  deceasedDateOfDeath    DateTime?

  // --- Estate Status ---
  isTestate              Boolean  @default(false) // Fact: derived from Will existence
  isIntestate            Boolean  @default(false)
  isFrozen               Boolean  @default(false) 
  frozenAt               DateTime?
  
  // --- Financial Summary (Updated via Domain Service events) ---
  grossValueKES          Float    @default(0)
  totalLiabilitiesKES    Float    @default(0)
  netEstateValueKES      Float    @default(0)
  
  // --- Hotchpot (S. 35(3) LSA) ---
  hotchpotAdjustedValueKES Float? // Gross + Gifts Inter Vivos
  
  // --- Aggregate Members (Entities) ---
  assets                 Asset[]
  debts                  Debt[]
  giftsInterVivos        GiftInterVivos[]
  legalDependants        LegalDependant[]       // MOVED HERE: Estate owns the claims against it
  
  // --- Simulation Snapshots (Read Models) ---
  distributionScenarios  DistributionScenario[] 

  estateTaxCompliance    EstateTaxCompliance?

  // --- Audit ---
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  
  @@index([deceasedId])
  @@map("estates")
}

// -----------------------------------------------------------------------------
// Entity: Asset (Polymorphic)
// Owned by: Estate
// -----------------------------------------------------------------------------
model Asset {
  id                   String   @id @default(uuid()) @db.Uuid()
  
  // --- Parent Aggregate ---
  estateId             String   @db.Uuid()
  estate               Estate   @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- Ownership ---
  ownerId              String   @db.Uuid() 
  owner                User     @relation("AssetOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  
  // --- Asset Details ---
  name                 String   @db.VarChar(200)
  description          String?  @db.Text
  type                 AssetType
  
  // --- Value ---
  currentValue         Float
  currency             String   @default("KES") @db.VarChar(10)
  valuationDate        DateTime?
  
  // --- Encumbrance & Status ---
  isEncumbered         Boolean  @default(false)
  encumbranceDetails   String?  @db.Text
  isActive             Boolean  @default(true) // Logical deletion
  
  // --- Polymorphic Relations (Asset Details) ---
  landDetails          LandAssetDetails?
  financialDetails     FinancialAssetDetails?
  vehicleDetails       VehicleAssetDetails?
  businessDetails      BusinessAssetDetails?
  
  // --- Child Entities ---
  valuations           AssetValuation[] // History of value
  coOwners             AssetCoOwner[]   // Ownership facts
  
  familyMembers        FamilyMember[] @relation("FamilyMemberLifeInterest")
  // --- Weak Links to other contexts ---
  // These exist to support the DB constraints but logic belongs to other aggregates
  debts                  Debt[]           @relation("SecuredDebtAsset")
  beneficiaryAssignments BeneficiaryAssignment[]
  
  // --- Succession Process Links (Kept for Referential Integrity) ---
  documents              Document[]
  assetLiquidations      AssetLiquidation[]

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([estateId, type])
  @@map("assets")
  
}
// --- Asset Detail Tables (Polymorphic extensions) ---
model LandAssetDetails {
  id                  String   @id @default(uuid()) @db.Uuid()
  assetId             String   @unique @db.Uuid()
  asset               Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  titleDeedNumber     String   @db.VarChar(100)
  parcelNumber        String?  @db.VarChar(100)
  county              KenyanCounty
  subCounty           String?
  acreage             Float
  landUse             String?
  
  @@map("land_asset_details")
}
model FinancialAssetDetails {
  id              String   @id @default(uuid()) @db.Uuid()
  assetId         String   @unique @db.Uuid()
  asset           Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  institutionName String   @db.VarChar(200)
  accountNumber   String   @db.VarChar(100)
  accountType     String   @db.VarChar(100)
  branchName      String?
  
  @@map("financial_asset_details")
}
model VehicleAssetDetails {
  id                 String   @id @default(uuid()) @db.Uuid()
  assetId            String   @unique @db.Uuid()
  asset              Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  registrationNumber String   @unique @db.VarChar(20)
  make               String   @db.VarChar(100)
  model              String   @db.VarChar(100)
  chassisNumber      String?
  
  @@map("vehicle_asset_details")
}
model BusinessAssetDetails {
  id                 String   @id @default(uuid()) @db.Uuid()
  assetId            String   @unique @db.Uuid()
  asset              Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  businessName       String   @db.VarChar(200)
  registrationNumber String?
  sharePercentage    Float
  
  @@map("business_asset_details")
}
model AssetValuation {
  id            String   @id @default(uuid()) @db.Uuid()
  assetId       String   @db.Uuid()
  asset         Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  value         Float
  valuationDate DateTime
  source        String?  @db.VarChar(100) // e.g. "Registered Valuer", "Market Estimate"
  notes         String?  @db.Text
  
  createdAt     DateTime @default(now())
  @@map("asset_valuations")
}
model AssetCoOwner {
  id           String   @id @default(uuid()) @db.Uuid()
  assetId      String   @db.Uuid()
  asset        Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  userId       String?  @db.Uuid() 
  user         User?    @relation("CoOwnerUser", fields: [userId], references: [id])
  
  externalName String?  @db.VarChar(200) // If not a system user
  sharePercent Float
  
  @@unique([assetId, userId])
  @@map("asset_co_owners")
}
// -----------------------------------------------------------------------------
// Entity: Asset Liquidation
// Owned by: Estate
// Purpose: Tracks the conversion of an Asset (Inventory) into Cash (Inventory)
// -----------------------------------------------------------------------------
model AssetLiquidation {
  id              String   @id @default(uuid()) @db.Uuid()
  
  // --- Inventory Links ---
  assetId         String   @db.Uuid()
  asset           Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  // --- Financial Result ---
  liquidationType String   @db.VarChar(50) // "SALE", "AUCTION"
  targetAmount    Float
  actualAmount    Float?   // This becomes "Cash" in the estate value
  currency        String   @default("KES") @db.VarChar(10)
  
  // --- Buyer (Optional) ---
  buyerName       String?  @db.VarChar(200)
  buyerIdNumber   String?  @db.VarChar(50)
  
  // --- Process Metadata ---
  saleDate        DateTime?
  approvedByCourt Boolean  @default(false) 
  courtOrderRef   String?  @db.VarChar(100) // Reference only, strictly text
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([assetId])
  @@map("asset_liquidations")
}
// -----------------------------------------------------------------------------
// Entity: Estate Tax Compliance
// Owned by: Estate
// Purpose: Tracks the tax liability status of the Estate (KRA)
// -----------------------------------------------------------------------------
model EstateTaxCompliance {
  id                         String   @id @default(uuid()) @db.Uuid()
  
  // --- Parent Aggregate ---
  estateId                   String   @unique @db.Uuid()
  estate                     Estate   @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- KRA Identity ---
  kraPin                     String?  @unique @db.VarChar(20)
  
  // --- Liability Status (Facts) ---
  incomeTaxPaid              Boolean  @default(false)
  capitalGainsTaxPaid        Boolean  @default(false)
  stampDutyPaid              Boolean  @default(false)
  
  // --- Certificates ---
  taxClearanceCertificateNo  String?  @db.VarChar(100)
  taxClearanceIssuedAt       DateTime?
  
  // --- Sync Status ---
  lastKraSyncAt              DateTime?
  kraSyncStatus              String?  @db.VarChar(50)
  
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt

  @@map("estate_tax_compliance")
}
// -----------------------------------------------------------------------------
// Entity: Debt
// Owned by: Estate
// -----------------------------------------------------------------------------
model Debt {
  id                  String       @id @default(uuid()) @db.Uuid()
  
  // --- Parent Aggregate ---
  estateId            String       @db.Uuid()
  estate              Estate       @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- Details ---
  description         String       @db.Text
  type                DebtType
  amount              Float
  outstandingBalance  Float
  
  // --- S.45 Priority Logic ---
  // The service calculates this, but we store the result for querying
  priority            DebtPriority @default(MEDIUM) 
  tier                DebtTier     // FUNERAL, SECURED, UNSECURED
  
  // --- Security ---
  isSecured           Boolean      @default(false)
  securedAssetId      String?      @db.Uuid()
  securedAsset        Asset?       @relation("SecuredDebtAsset", fields: [securedAssetId], references: [id])
  
  // --- Status ---
  dueDate             DateTime?
  isStatuteBarred     Boolean      @default(false) // Validated by Domain Service
  status              DebtStatus   @default(OUTSTANDING)
  
  // --- Creditor Info ---
  creditorName        String
  
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt

  @@index([estateId, tier])
  @@map("debts")
}
// -----------------------------------------------------------------------------
// Entity: Gift Inter Vivos (For S.35 Hotchpot)
// Owned by: Estate
// -----------------------------------------------------------------------------
model GiftInterVivos {
  id              String   @id @default(uuid()) @db.Uuid()
  estateId        String   @db.Uuid()
  estate          Estate   @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- Recipient ---
  recipientId     String   @db.Uuid() 
  recipient       FamilyMember @relation("GiftRecipient", fields: [recipientId], references: [id])
  
  // --- Value ---
  assetType       AssetType
  valueAtGiftTimeKES Float
  dateOfGift      DateTime
  description     String?
  
  // --- Logic ---
  // Should this be added back to estate value?
  isSubjectToHotchpot Boolean @default(true) 
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("gifts_inter_vivos")
}

// -----------------------------------------------------------------------------
// Entity: Legal Dependant (S.26 / S.29)
// Owned by: Estate (MOVED from separate aggregate)
// -----------------------------------------------------------------------------
model LegalDependant {
  id              String   @id @default(uuid()) @db.Uuid()
  
  // --- Parent Aggregate ---
  estateId        String   @db.Uuid()
  estate          Estate   @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- Claimant Identity ---
  dependantId     String   @db.Uuid() // FamilyMember ID
  dependant       FamilyMember @relation("DependantOf", fields: [dependantId], references: [id])
  
  // We keep the deceased relation for direct lookup, but ownership is via Estate
  deceasedId      String   @db.Uuid()
  deceased        FamilyMember @relation("DeceasedDependant", fields: [deceasedId], references: [id])
  
  // --- Dependency Facts ---
  basisSection    KenyanLawSection // S.29(a) Spouse, S.29(b) Child, etc.
  dependencyLevel DependencyLevel  // FULL, PARTIAL
  
  // --- Financials ---
  monthlyNeeds    Float?
  dependencyPercentage Float @default(100)
  
  // --- Verification ---
  isVerified      Boolean  @default(false)
  evidences       DependantEvidence[]
  
  // --- Custodial (if minor) ---
  custodialParentId String? @db.Uuid()
  custodialParent   FamilyMember? @relation("CustodialParent", fields: [custodialParentId], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([estateId, dependantId])
  @@map("legal_dependants")
}
model DependantEvidence {
  id              String   @id @default(uuid()) @db.Uuid()
  dependantId     String   @db.Uuid()
  dependant       LegalDependant @relation(fields: [dependantId], references: [id], onDelete: Cascade)
  
  evidenceType    String   // "SCHOOL_RECEIPT", "MEDICAL_REPORT"
  documentId      String?  @db.Uuid() // Link to Documents Service
  description     String?
  
  createdAt       DateTime @default(now())
  @@map("dependant_evidence")
}
// =============================================================================
// AGGREGATE ROOT 2: WILL
// Purpose: Testamentary Instructions.
// Invariants: Only 1 active will per user. Must have 2 witnesses.
// =============================================================================
model Will {
  id                     String   @id @default(uuid()) @db.Uuid()
  
  // --- Testator Identity ---
  testatorId             String   @db.Uuid() 
  testator               User     @relation("TestatorWills", fields: [testatorId], references: [id])
  
  // --- Lifecycle ---
  status                 WillStatus @default(DRAFT)
  type                   WillType   @default(STANDARD)
  versionNumber          Int        @default(1)
  
  // --- Revocation ---
  isRevoked              Boolean    @default(false)
  revocationMethod       RevocationMethod?
  revokedAt              DateTime?
  supersedesId           String?    @db.Uuid()
  supersededWill         Will?      @relation("WillSupersession", fields: [supersedesId], references: [id])
  supersededBy           Will[]     @relation("WillSupersession")

  // --- Instructions ---
  funeralWishes          String?  @db.Text
  burialLocation         String?
  residuaryClause        String?  @db.Text // "Everything else goes to..."
  
  // --- Aggregate Members ---
  executors              WillExecutor[]
  witnesses              WillWitness[]
  beneficiaryAssignments BeneficiaryAssignment[]
  codicils               Codicil[]
  disinheritanceRecords  DisinheritanceRecord[]
  
  // --- Metadata ---
  documents              Document[]
  probateCaseNumber      String? // Informational only

  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  
  @@index([testatorId, status])
  @@map("wills")
}
// -----------------------------------------------------------------------------
// Entity: Will Executor (Nomination)
// Owned by: Will
// -----------------------------------------------------------------------------
model WillExecutor {
  id              String   @id @default(uuid()) @db.Uuid()
  willId          String   @db.Uuid()
  will            Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  // Identity (Optional link to user, otherwise external details)
  executorId      String?  @db.Uuid()
  executorUser    User?    @relation("ExecutorUser", fields: [executorId], references: [id])
  
  fullName        String?
  email           String?
  phone           String?
  
  isPrimary       Boolean  @default(false)
  appointmentType ExecutorAppointmentType @default(TESTAMENTARY)
  
  @@map("will_executors")
}

// -----------------------------------------------------------------------------
// Entity: Will Witness
// Owned by: Will
// -----------------------------------------------------------------------------
model WillWitness {
  id              String   @id @default(uuid()) @db.Uuid()
  willId          String   @db.Uuid()
  will            Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  // Identity
  witnessId       String?  @db.Uuid()
  witnessUser     User?    @relation("WitnessUser", fields: [witnessId], references: [id])
  
  fullName        String
  nationalId      String?
  
  status          WitnessStatus @default(PENDING)
  signedAt        DateTime?
  
  documents       Document[] @relation("WitnessIdentityDocuments")
  
  @@map("will_witnesses")
}

// -----------------------------------------------------------------------------
// Entity: Beneficiary Assignment
// Owned by: Will
// -----------------------------------------------------------------------------
model BeneficiaryAssignment {
  id              String   @id @default(uuid()) @db.Uuid()
  willId          String   @db.Uuid()
  will            Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  // --- What (Weak Link to Asset) ---
  assetId         String?  @db.Uuid() 
  asset           Asset?   @relation(fields: [assetId], references: [id]) // Logic controlled by Service
  isResiduary     Boolean  @default(false)
  sharePercentage Float?
  specificAmount  Float?
  
  // --- Who ---
  beneficiaryType BeneficiaryType
  userId          String?  @db.Uuid()
  beneficiaryUser User?    @relation("AssignmentBeneficiaryUser", fields: [userId], references: [id])
  
  familyMemberId  String?  @db.Uuid()
  beneficiaryFamilyMember FamilyMember? @relation("BeneficiaryFamilyMember", fields: [familyMemberId], references: [id])
  
  externalName    String?
  
  // --- Conditions ---
  conditionType   BequestConditionType @default(NONE)
  conditionDetails String? @db.Text 
  
  // --- Alternate ---
  alternateAssignmentId String? @db.Uuid()
  alternateAssignment   BeneficiaryAssignment? @relation("AlternateBeneficiary", fields: [alternateAssignmentId], references: [id])
  alternateFor          BeneficiaryAssignment[] @relation("AlternateBeneficiary")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("beneficiary_assignments")
}

// -----------------------------------------------------------------------------
// Entity: Codicil
// Owned by: Will
// -----------------------------------------------------------------------------
model Codicil {
  id              String   @id @default(uuid()) @db.Uuid()
  willId          String   @db.Uuid()
  will            Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  title           String   @db.VarChar(200)
  content         String   @db.Text
  codicilDate     DateTime
  versionNumber   Int      @default(1)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("codicils")
}

// -----------------------------------------------------------------------------
// Entity: Disinheritance Record
// Owned by: Will
// -----------------------------------------------------------------------------
model DisinheritanceRecord {
  id              String   @id @default(uuid()) @db.Uuid()
  willId          String   @db.Uuid()
  will            Will     @relation(fields: [willId], references: [id], onDelete: Cascade)
  
  disinheritedMemberId String @db.Uuid()
  disinheritedMember   FamilyMember @relation("DisinheritedMember", fields: [disinheritedMemberId], references: [id])
  
  reason          String?  @db.Text
  
  @@map("disinheritance_records")
}

// =============================================================================
// READ MODELS / SNAPSHOTS
// Domain Service Output Storage (Attached to Estate)
// NOT an Aggregate.
// =============================================================================

model DistributionScenario {
  id                      String   @id @default(uuid()) @db.Uuid()
  
  // --- Owner ---
  estateId                String   @db.Uuid()
  estate                  Estate   @relation(fields: [estateId], references: [id], onDelete: Cascade)
  
  // --- Metadata ---
  scenarioName            String   @db.VarChar(100)
  scenarioType            String   @default("INTESTATE") // "TESTATE", "INTESTATE_S35", "INTESTATE_S40"
  description             String?  
  
  // --- Input Config (Snapshot of parameters) ---
  appliedLawSection       KenyanLawSection
  polygamousHouseCount    Int      @default(0)
  
  // --- Output Results ---
  totalNetValueKES        Float
  computedShares          ComputedShareDetail[]

  createdAt               DateTime @default(now())
  
  @@unique([estateId, scenarioName])
  @@map("distribution_scenarios")
}
model ComputedShareDetail {
  id                      String   @id @default(uuid()) @db.Uuid()
  
  scenarioId              String   @db.Uuid()
  scenario                DistributionScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  
  // --- Snapshot of Beneficiary ---
  heirId                  String?  @db.Uuid() 
  heirName                String
  heirRelationship        String   
  
  // --- The Math ---
  finalSharePercent       Float
  finalShareValueKES      Float
  
  // --- Legal Nature ---
  shareType               String   // "ABSOLUTE", "LIFE_INTEREST"
  polygamousHouseId       String?  @db.Uuid()
  
  @@map("computed_share_details")
}
// ============================================================================
// SUCCESSION-AUTOMATION SERVICE
// Purpose: "The Digital Lawyer". Generates forms, tracks readiness, guides the user.
// Updates: Includes SuccessionContext and RiskSource for traceability.
// ============================================================================

// =============================================================================
// AGGREGATE 1: READINESS ASSESSMENT
// Purpose: Analyzes Family + Estate to tell user if they are ready to go to court.
// =============================================================================
model ReadinessAssessment {
  id                  String   @id @default(uuid()) @db.Uuid()
  
  // --- Target ---
  estateId            String   @unique @db.Uuid() 
  
  // --- Scorecard ---
  readinessScore      Int      @default(0) // 0-100%
  status              ReadinessStatus @default(IN_PROGRESS)
  
  // --- [NEW] SUCCESSION CONTEXT (Value Object Flattened) ---
  // This drives the entire logic engine (e.g., Islamic cases need different forms)
  contextRegime       SuccessionRegime   // TESTATE, INTESTATE
  contextMarriage     SuccessionMarriageType // MONOGAMOUS, POLYGAMOUS
  contextReligion     SuccessionReligion // STATUTORY, ISLAMIC, HINDU, CUSTOMARY
  
  // --- Findings ---
  missingDocuments    Json?    // ["DeathCert", "ChiefLetter"]
  blockingIssues      Json?    // ["MinorWithoutGuardian", "DisputedAsset"]
  recommendedStrategy String?  // e.g. "Apply to Kadhi's Court for Grant"
  
  // --- Child Entities ---
  riskFlags           RiskFlag[]
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@map("readiness_assessments")
}
model RiskFlag {
  id              String   @id @default(uuid()) @db.Uuid()
  assessmentId    String   @db.Uuid()
  assessment      ReadinessAssessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  
  // --- Risk Details ---
  severity        RiskSeverity @default(HIGH)
  category        String   // "DOCUMENT", "FAMILY_DISPUTE", "ASSET_VERIFICATION"
  description     String   @db.Text
  mitigationSteps String?  @db.Text
  
  // --- [NEW] EVIDENCE SOURCE ---
  // Where did we find this risk? (Traceability)
  source          RiskSource
  sourceId        String?  @db.Uuid() // ID of the specific entity (e.g., Will ID, Asset ID)
  
  isResolved      Boolean  @default(false)
  resolvedAt      DateTime?
  
  @@map("risk_flags")
}
// =============================================================================
// AGGREGATE 2: PROBATE APPLICATION (The Generator)
// Purpose: Compiles the "Bundle" for court based on the Context.
// =============================================================================

model ProbateApplication {
  id                  String   @id @default(uuid()) @db.Uuid()
  estateId            String   @db.Uuid()
  
  // --- Application Details ---
  // The system suggests this based on ReadinessAssessment Context
  applicationType     ProbateApplicationType 
  applicantUserId     String   @db.Uuid()    
  
  // --- Court Interaction ---
  courtStation        String   @db.VarChar(100)
  caseNumber          String?  @db.VarChar(100) 
  filingDate          DateTime?
  
  // --- Automation Status ---
  formsGenerated      Boolean  @default(false)
  allConsentsReceived Boolean  @default(false)
  
  // --- Child Entities ---
  generatedForms      GeneratedForm[]
  familyConsents      FamilyConsent[]
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([estateId])
  @@map("probate_applications")
}

model GeneratedForm {
  id              String   @id @default(uuid()) @db.Uuid()
  applicationId   String   @db.Uuid()
  application     ProbateApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  formType        KenyanFormType
  s3Url           String   @db.Text
  generatedAt     DateTime @default(now())
  
  metadata        Json?    
  
  @@map("generated_forms")
}

model FamilyConsent {
  id              String   @id @default(uuid()) @db.Uuid()
  applicationId   String   @db.Uuid()
  application     ProbateApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  familyMemberId  String   @db.Uuid()
  role            String   // "Beneficiary", "HouseholdHead"
  
  consentStatus   ConsentStatus @default(PENDING)
  consentGivenAt  DateTime?
  digitalSignatureId String? 
  rejectionReason String?  @db.Text
  
  createdAt       DateTime @default(now())
  @@map("family_consents")
}
// =============================================================================
// AGGREGATE 3: EXECUTOR ROADMAP (The GPS)
// Purpose: Dynamic Task List based on Context.
// =============================================================================
model ExecutorRoadmap {
  id                  String   @id @default(uuid()) @db.Uuid()
  estateId            String   @unique @db.Uuid()
  
  currentPhase        RoadmapPhase @default(PRE_FILING)
  percentComplete     Int          @default(0)
  
  tasks               RoadmapTask[]
  
  updatedAt           DateTime @updatedAt
  @@map("executor_roadmaps")
}
model RoadmapTask {
  id              String   @id @default(uuid()) @db.Uuid()
  roadmapId       String   @db.Uuid()
  roadmap         ExecutorRoadmap @relation(fields: [roadmapId], references: [id], onDelete: Cascade)
  
  title           String   
  description     String   @db.Text
  category        String   
  
  status          TaskStatus @default(PENDING)
  dueDate         DateTime?
  completedAt     DateTime?
  
  dependsOnTaskId String?  @db.Uuid() 
  proofDocumentId String?  @db.Uuid() 
  
  createdAt       DateTime @default(now())
  @@map("roadmap_tasks")
}
// =============================================================================
// NOTIFICATIONS SERVICE MODELS
// Owner: notifications-service
// =============================================================================

model NotificationTemplate {
  id      String              @id @default(uuid()) @db.Uuid()
  name    String              @unique(map: "notification_templates_name_unique") @db.VarChar(100)
  channel NotificationChannel
  subject String?             @db.VarChar(255)
  body    String              @db.Text

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  notifications Notification[]

  @@map("notification_templates")
}

model Notification {
  id          String             @id @default(uuid()) @db.Uuid()
  channel     NotificationChannel
  status      NotificationStatus @default(PENDING)
  sentAt      DateTime?
  failReason  String?            @db.Text
  templateId  String             @db.Uuid()
  template    NotificationTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  recipientId String?            @db.Uuid()
  recipient   User?              @relation(fields: [recipientId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  createdAt   DateTime           @default(now())

  @@index([recipientId, status], map: "notifications_recipient_status_idx")
  @@map("notifications")
}
// =============================================================================
// AUDITING SERVICE MODEL
// Owner: auditing-service
// =============================================================================

model AuditLog {
  id        String   @id @default(uuid()) @db.Uuid()
  timestamp DateTime @default(now())
  actorId   String?  @db.Uuid()
  actor     User?    @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  action    String   @db.VarChar(100)
  payload   Json

  @@index([actorId], map: "audit_logs_actorId_idx")
  @@index([action, timestamp], map: "audit_logs_action_timestamp_idx")
  @@map("audit_logs")
}
